<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless 3D Driving Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
    </style>
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
    <!-- GLTFLoader from CDN -->
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div id="ui">Score: <span id="score">0</span><br>Use ← → or A D to change lanes<br>Gamepad supported</div>
    <script>
        // ==================== THREE.JS SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);
        scene.fog = new THREE.FogExp2(0x88ccff, 0.0008);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // ==================== ROAD GENERATION (Curve-based) ====================
        // Comment: Curve-based road generation using CatmullRomCurve3 for smooth, continuous, gap-free road.
        // Control points are generated procedurally with random turns, elevations, and occasional speed bumps.
        // Road is flat, generated as a ribbon mesh along the curve.
        const ROAD_WIDTH = 12;
        const LANE_WIDTH = ROAD_WIDTH / 4;
        const LANE_CENTERS = [-4.5, -1.5, 1.5, 4.5];

        let curve;
        let controlPoints = [];
        const SEGMENT_LENGTH = 30;
        const SEGMENTS_AHEAD = 30;
        const SEGMENTS_BEHIND = 10;

        let roadMesh;
        let roadGeometry;
        let roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide });

        function generateInitialCurve() {
            controlPoints = [];
            for (let i = 0; i < SEGMENTS_AHEAD + SEGMENTS_BEHIND; i++) {
                addControlPoint(i);
            }
            updateCurve();
            createRoadMesh();
        }

        function addControlPoint(index) {
            const t = index * SEGMENT_LENGTH;
            const point = new THREE.Vector3(
                randomTurn(index),
                randomElevation(index),
                -t
            );
            controlPoints.push(point);
        }

        function randomTurn(index) {
            if (index % 20 === 0) {
                return (Math.random() < 0.5 ? 1 : -1) * (Math.random() < 0.7 ? 2 : 5);
            }
            return 0;
        }

        function randomElevation(index) {
            return Math.sin(index * 0.1) * 2.5;
        }

        function addSpeedBump(startIndex) {
            for (let i = 0; i < 3; i++) {
                const idx = startIndex + i;
                if (controlPoints[idx]) {
                    controlPoints[idx].y += Math.sin(i * Math.PI / 3) * 1.5;
                }
            }
        }

        function extendCurve() {
            const newIndex = controlPoints.length;
            addControlPoint(newIndex);
            if (newIndex % 40 === 0) {
                addSpeedBump(newIndex);
            }
            updateCurve();
            // Dispose old geometry behind
            if (controlPoints.length > SEGMENTS_AHEAD + SEGMENTS_BEHIND + 20) {
                controlPoints.shift();
            }
            createRoadMesh(); // Regenerate for simplicity, optimize if needed
        }

        function updateCurve() {
            curve = new THREE.CatmullRomCurve3(controlPoints);
            curve.curveType = 'centripetal';
            curve.tension = 0.5;
        }

        function createRoadMesh() {
            if (roadGeometry) roadGeometry.dispose();
            if (roadMesh) scene.remove(roadMesh);

            // Custom flat road geometry along curve
            const divisions = controlPoints.length * 10;
            const points = curve.getPoints(divisions);
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const normals = [];

            for (let i = 0; i < divisions; i++) {
                const point = points[i];
                const tangent = curve.getTangent(i / divisions).normalize();
                const normal = new THREE.Vector3(0, 1, 0); // Approximate flat
                const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();

                const left = point.clone().add(binormal.multiplyScalar(-ROAD_WIDTH / 2));
                const right = point.clone().add(binormal.multiplyScalar(ROAD_WIDTH / 2));

                vertices.push(left.x, left.y, left.z);
                vertices.push(right.x, right.y, right.z);
                normals.push(0, 1, 0);
                normals.push(0, 1, 0);

                if (i < divisions - 1) {
                    const index = i * 2;
                    indices.push(index, index + 1, index + 2);
                    indices.push(index + 1, index + 3, index + 2);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setIndex(indices);

            roadGeometry = geometry;
            roadMesh = new THREE.Mesh(geometry, roadMaterial);
            roadMesh.receiveShadow = true;
            roadMesh.castShadow = true;
            scene.add(roadMesh);
        }

        generateInitialCurve();

        // ==================== ASSET AUTO-DETECTION LOGIC ====================
        // Comment: Asset auto-detection logic: In a real server setup, we would fetch the list of files in /models/ using fetch('/models/') and parse the directory listing.
        // Since this is a single HTML file and browsers can't list directories, we simulate with a hardcoded array of model names.
        // Roles are assigned by checking if filename contains 'player', 'enemy', or 'npc' (case-insensitive).
        // In production, replace availableModels with dynamic fetch and filter.
        const MODEL_BASE = './models/'; // Assume relative path
        const availableModels = [
            'player.glb',
            'enemyCar.glb',
            'npc.glb'
        ];

        let playerModels = [];
        let enemyModels = [];
        let npcModels = [];

        availableModels.forEach(name => {
            const lower = name.toLowerCase();
            if (lower.includes('player')) playerModels.push(MODEL_BASE + name);
            else if (lower.includes('enemy')) enemyModels.push(MODEL_BASE + name);
            else if (lower.includes('npc')) npcModels.push(MODEL_BASE + name);
        });

        const gltfLoader = new THREE.GLTFLoader();

        function loadRandomModel(urls, colorFallback, callback) {
            if (urls.length === 0) {
                // Fallback to box if no models
                const geometry = new THREE.BoxGeometry(1.5, 1, 3);
                const material = new THREE.MeshStandardMaterial({ color: colorFallback });
                const model = new THREE.Mesh(geometry, material);
                model.castShadow = true;
                model.receiveShadow = true;
                callback(model);
                return;
            }
            const url = urls[Math.floor(Math.random() * urls.length)];
            gltfLoader.load(url, gltf => {
                const model = gltf.scene;
                model.scale.set(1,1,1); // Adjust if needed
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                callback(model);
            }, undefined, err => {
                console.error('Model load error, using fallback', err);
                loadRandomModel([], colorFallback, callback); // Fallback on error
            });
        }

        // ==================== PLAYER CAR ====================
        let playerCar;
        let playerLane = 1; // Start in lane 1 (index 1, -1.5)
        let targetLane = 1;
        let speed = 0;
        const MAX_SPEED = 0.8;
        const ACCELERATION = 0.001;

        loadRandomModel(playerModels, 0x00ff00, model => { // Green fallback
            playerCar = model;
            playerCar.position.set(LANE_CENTERS[playerLane], 0.5, 0);
            scene.add(playerCar);
        });

        // ==================== ENEMY & NPC CARS ====================
        const otherCars = [];
        const CAR_SPAWN_INTERVAL = 5; // Seconds approx

        function spawnOtherCar(isEnemy = Math.random() < 0.5) {
            const models = isEnemy ? enemyModels : npcModels;
            const color = isEnemy ? 0xff0000 : 0x0000ff; // Red enemy, blue NPC
            loadRandomModel(models, color, model => {
                const lane = Math.floor(Math.random() * 4);
                model.position.set(LANE_CENTERS[lane], 0.5, playerCar.position.z - 50 - Math.random() * 200);
                model.userData = {
                    isEnemy,
                    lane,
                    speed: isEnemy ? 0.6 + Math.random() * 0.2 : 0.4 + Math.random() * 0.3,
                    changeLaneTimer: Math.random() * 10
                };
                scene.add(model);
                otherCars.push(model);
            });
        }

        // Initial spawns
        for (let i = 0; i < 10; i++) {
            spawnOtherCar(i % 2 === 0);
        }

        // ==================== LANE SNAPPING SYSTEM ====================
        // Comment: Lane snapping: Player targets a lane index (0-3), position.x lerps smoothly to LANE_CENTERS[target].
        // No free sliding, only discrete lane changes on input.

        // ==================== CONTROLS ====================
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        let gamepadIndex = null;
        window.addEventListener('gamepadconnected', e => gamepadIndex = e.gamepad.index);

        function handleInput(delta) {
            let left = keys['a'] || keys['arrowleft'];
            let right = keys['d'] || keys['arrowright'];

            if (gamepadIndex !== null) {
                const gp = navigator.getGamepads()[gamepadIndex];
                if (gp) {
                    const axis = gp.axes[0] || 0;
                    if (axis < -0.5) left = true;
                    if (axis > 0.5) right = true;
                }
            }

            if (left && targetLane > 0) targetLane--;
            if (right && targetLane < 3) targetLane++;
        }

        // ==================== PROCEDURAL BUILDINGS ====================
        const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const buildings = [];

        function spawnBuildings() {
            const zPos = playerCar ? playerCar.position.z - 300 - Math.random() * 100 : -300;
            for (let i = 0; i < 5; i++) {
                const side = Math.random() < 0.5 ? -1 : 1;
                const xOffset = side * (ROAD_WIDTH / 2 + 10 + Math.random() * 30);
                const height = 10 + Math.random() * 20;
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(8 + Math.random() * 10, height, 8 + Math.random() * 10),
                    buildingMaterial
                );
                building.position.set(xOffset, height / 2, zPos - i * 50);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                buildings.push(building);
            }
        }

        spawnBuildings(); // Initial

        // ==================== GAME LOOP ====================
        let lastTime = 0;
        let score = 0;
        const scoreElement = document.getElementById('score');
        let spawnTimer = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            if (!lastTime) lastTime = time;
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            if (playerCar) {
                handleInput(delta);

                // Accelerate
                speed = Math.min(speed + ACCELERATION, MAX_SPEED);

                // Move player along curve
                const distance = speed * delta * SEGMENT_LENGTH; // Adjust scale
                const t = -playerCar.position.z / (controlPoints.length * SEGMENT_LENGTH) + distance;
                const pos = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);

                playerCar.position.copy(pos);
                playerCar.position.y += 0.5; // Above road
                playerCar.position.x = THREE.MathUtils.lerp(playerCar.position.x, LANE_CENTERS[targetLane], 0.1);

                playerCar.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), tangent);

                // Camera
                const camPos = playerCar.position.clone().add(tangent.clone().multiplyScalar(-15)).add(new THREE.Vector3(0, 5, 0));
                camera.position.lerp(camPos, 0.1);
                camera.lookAt(playerCar.position.clone().add(tangent.multiplyScalar(10)));

                // Extend road
                if (-playerCar.position.z > (controlPoints.length - SEGMENTS_AHEAD) * SEGMENT_LENGTH) {
                    extendCurve();
                }

                // Update score
                score += speed * 100 * delta;
                scoreElement.textContent = Math.floor(score);

                // Spawn more cars based on difficulty
                spawnTimer += delta;
                if (spawnTimer > CAR_SPAWN_INTERVAL / (1 + score / 10000)) {
                    spawnOtherCar(Math.random() < 0.3 + score / 20000); // More enemies over time
                    spawnTimer = 0;
                }

                // Update other cars
                otherCars.forEach((car, index) => {
                    const carT = -car.position.z / (controlPoints.length * SEGMENT_LENGTH) + car.userData.speed * delta;
                    const carPos = curve.getPointAt(carT);
                    const carTangent = curve.getTangentAt(carT);

                    car.position.copy(carPos);
                    car.position.y += 0.5;
                    car.position.x = THREE.MathUtils.lerp(car.position.x, LANE_CENTERS[car.userData.lane], 0.1);

                    car.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), carTangent);

                    // Enemy behavior: change lane to match player occasionally
                    car.userData.changeLaneTimer -= delta;
                    if (car.userData.isEnemy && car.userData.changeLaneTimer < 0) {
                        if (Math.random() < 0.2) {
                            car.userData.lane = targetLane; // Try to ram player
                        } else {
                            car.userData.lane = Math.max(0, Math.min(3, car.userData.lane + (Math.random() < 0.5 ? -1 : 1)));
                        }
                        car.userData.changeLaneTimer = 5 + Math.random() * 5;
                    }

                    // NPC random speed variation
                    if (!car.userData.isEnemy) {
                        car.userData.speed += (Math.random() - 0.5) * 0.01;
                        car.userData.speed = THREE.MathUtils.clamp(car.userData.speed, 0.3, 0.7);
                    }

                    // Collision detection
                    if (car.position.distanceTo(playerCar.position) < 3) {
                        if (car.userData.isEnemy) {
                            alert('Game Over! Collided with enemy. Score: ' + Math.floor(score));
                            location.reload();
                        } // NPCs could be obstacles, but for now no game over
                    }

                    // Remove far behind
                    if (car.position.z > playerCar.position.z + 50) {
                        scene.remove(car);
                        otherCars.splice(index, 1);
                    }
                });

                // Spawn buildings
                if (Math.random() < 0.05) spawnBuildings();

                // Remove far buildings
                buildings.forEach((b, idx) => {
                    if (b.position.z > playerCar.position.z + 50) {
                        scene.remove(b);
                        buildings.splice(idx, 1);
                    }
                });
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate(0);
    </script>
</body>
</html>
