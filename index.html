<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless 3D Road Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 100%);
            color: #333;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #ui h2 {
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 1.4em;
        }
        
        .ui-row {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .ui-label {
            color: #aaa;
        }
        
        .ui-value {
            font-weight: bold;
            color: white;
        }
        
        #speedBar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        #speedFill {
            height: 100%;
            width: 30%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #controls h3 {
            margin-bottom: 10px;
            color: #FF9800;
        }
        
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            margin: 2px;
            border-radius: 5px;
            font-family: monospace;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            min-width: 300px;
            border: 2px solid #4CAF50;
        }
        
        #loading h2 {
            margin-bottom: 15px;
            color: #4CAF50;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 15px;
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            min-width: 350px;
            display: none;
            border: 3px solid #FF5252;
            box-shadow: 0 0 30px rgba(255, 82, 82, 0.5);
        }
        
        #gameOver h2 {
            font-size: 2.5em;
            color: #FF5252;
            margin-bottom: 20px;
        }
        
        #gameOver button {
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }
        
        #gameOver button:hover {
            transform: scale(1.05);
        }
        
        #roadCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <h2>ROAD RUNNER</h2>
            <div class="ui-row">
                <span class="ui-label">SCORE:</span>
                <span id="score" class="ui-value">0</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">SPEED:</span>
                <span id="speed" class="ui-value">60 km/h</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">DISTANCE:</span>
                <span id="distance" class="ui-value">0 m</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">ENEMIES:</span>
                <span id="enemies" class="ui-value">0</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">LANE:</span>
                <span id="lane" class="ui-value">2</span>
            </div>
            <div id="speedBar">
                <div id="speedFill"></div>
            </div>
        </div>
        
        <div id="controls">
            <h3>CONTROLS</h3>
            <p><span class="key">W</span>/<span class="key">↑</span> - Accelerate</p>
            <p><span class="key">A</span>/<span class="key">←</span> - Left Lane</p>
            <p><span class="key">D</span>/<span class="key">→</span> - Right Lane</p>
            <p><span class="key">S</span>/<span class="key">↓</span> - Brake</p>
            <p style="margin-top: 10px; color: #FF9800;">Gamepad Supported</p>
        </div>
        
        <div id="loading">
            <h2>LOADING GAME</h2>
            <p id="loadingText">Initializing 3D engine...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="loadingProgress"></div>
            </div>
        </div>
        
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <p>You crashed!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Distance Traveled: <span id="finalDistance">0 m</span></p>
            <button onclick="restartGame()">PLAY AGAIN</button>
        </div>
        
        <canvas id="roadCanvas"></canvas>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // Import Three.js modules
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://unpkg.com/three@0.162.0/examples/jsm/loaders/GLTFLoader.js';

        // ====================
        // GAME CONFIGURATION
        // ====================
        const CONFIG = {
            // Road settings - 4 identical lanes with proper mathematics
            ROAD_WIDTH: 20,
            ROAD_LENGTH: 3000, // Extended for behind camera
            SHOULDER_WIDTH: 2.0,
            SEGMENT_LENGTH: 25,
            TOTAL_LANES: 4,
            LANE_WIDTH: 0, // Will be calculated
            
            // Game settings
            INITIAL_SPEED: 20,
            MAX_SPEED: 120,
            ACCELERATION: 0.1,
            LANE_CHANGE_SPEED: 0.2,
            
            // Enemy settings
            MAX_ENEMIES: 8,
            ENEMY_SPAWN_INTERVAL: 2000,
            ENEMY_SPEED_VARIATION: 0.8,
            
            // NPC settings
            MAX_NPCS: 12,
            NPC_SPAWN_INTERVAL: 3000,
            NPC_SPEED_VARIATION: 0.6,
            
            // Visual settings
            FOG_DENSITY: 0.001,
            FOG_COLOR: 0x87CEEB,
            
            // External assets paths (fixed: models not /models)
            ASSET_PATHS: {
                PLAYER_CAR: 'models/player.glb',
                ENEMY_CAR: 'models/enemyCar.glb',
                NPC_CAR: 'models/npc.glb'
            }
        };

        // Calculate lane width mathematically: (Road Width - Shoulders) / 4 lanes
        CONFIG.LANE_WIDTH = (CONFIG.ROAD_WIDTH - (CONFIG.SHOULDER_WIDTH * 2)) / CONFIG.TOTAL_LANES;

        // ====================
        // GAME STATE
        // ====================
        let gameState = {
            score: 0,
            distance: 0,
            speed: CONFIG.INITIAL_SPEED,
            currentLane: 2,
            targetLane: 2,
            gameOver: false,
            playerCar: null,
            enemies: [],
            npcs: [],
            lastEnemySpawn: 0,
            lastNPCSpawn: 0,
            gamepad: null,
            assetsLoaded: false,
            carModels: {
                player: null,
                enemy: null,
                npc: null
            }
        };

        // ====================
        // MATHEMATICAL LANE SYSTEM
        // ====================
        function getLaneCenter(laneIndex) {
            // Lane indices: 0 (leftmost) to 3 (rightmost)
            const roadLeftEdge = -CONFIG.ROAD_WIDTH / 2 + CONFIG.SHOULDER_WIDTH;
            
            // Exact center of each lane using formula: leftEdge + (laneIndex * laneWidth) + (laneWidth / 2)
            return roadLeftEdge + (laneIndex * CONFIG.LANE_WIDTH) + (CONFIG.LANE_WIDTH / 2);
        }

        function snapCarToLaneCenter(car, laneIndex) {
            if (car) {
                car.position.x = getLaneCenter(laneIndex);
            }
        }

        function getLaneBoundaries() {
            const roadLeftEdge = -CONFIG.ROAD_WIDTH / 2 + CONFIG.SHOULDER_WIDTH;
            const drivableWidth = CONFIG.ROAD_WIDTH - (CONFIG.SHOULDER_WIDTH * 2);
            
            return {
                // Solid white lines at far edges
                leftSolid: -CONFIG.ROAD_WIDTH / 2 + CONFIG.SHOULDER_WIDTH,
                rightSolid: CONFIG.ROAD_WIDTH / 2 - CONFIG.SHOULDER_WIDTH,
                
                // Dashed lines at 25%, 50%, 75% of road width
                dash25: roadLeftEdge + (drivableWidth * 0.25),
                dash50: roadLeftEdge + (drivableWidth * 0.50), // Center line (yellow)
                dash75: roadLeftEdge + (drivableWidth * 0.75),
                
                // Road boundaries
                roadLeftEdge: roadLeftEdge,
                roadRightEdge: roadLeftEdge + drivableWidth
            };
        }

        // ====================
        // THREE.JS SETUP
        // ====================
        let scene, camera, renderer;
        let roadMesh, skybox;
        let clock = new THREE.Clock();
        let loader = new GLTFLoader();
        
        // Update loading progress
        function updateLoading(text, progress) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingProgress').style.width = `${progress}%`;
        }
        
        // Load external assets
        async function loadAssets() {
            updateLoading("Loading car models...", 20);
            
            try {
                // Load player car
                if (CONFIG.ASSET_PATHS.PLAYER_CAR) {
                    const playerModel = await loader.loadAsync(CONFIG.ASSET_PATHS.PLAYER_CAR);
                    gameState.carModels.player = playerModel.scene;
                    gameState.carModels.player.scale.set(1.5, 1.5, 1.5);
                    gameState.carModels.player.rotation.y = Math.PI; // Rotate 180 degrees for taillights
                }
                
                updateLoading("Loading enemy models...", 40);
                
                // Load enemy car
                if (CONFIG.ASSET_PATHS.ENEMY_CAR) {
                    const enemyModel = await loader.loadAsync(CONFIG.ASSET_PATHS.ENEMY_CAR);
                    gameState.carModels.enemy = enemyModel.scene;
                    gameState.carModels.enemy.scale.set(1.5, 1.5, 1.5);
                    gameState.carModels.enemy.rotation.y = Math.PI; // Rotate 180 degrees
                }
                
                updateLoading("Loading NPC models...", 60);
                
                // Load NPC car
                if (CONFIG.ASSET_PATHS.NPC_CAR) {
                    const npcModel = await loader.loadAsync(CONFIG.ASSET_PATHS.NPC_CAR);
                    gameState.carModels.npc = npcModel.scene;
                    gameState.carModels.npc.scale.set(1.5, 1.5, 1.5);
                    gameState.carModels.npc.rotation.y = Math.PI; // Rotate 180 degrees
                }
                
                gameState.assetsLoaded = true;
                updateLoading("Assets loaded!", 80);
                
            } catch (error) {
                console.warn("Could not load GLB models, using fallback geometry:", error);
                // Fallback to primitive geometry if models don't exist
                createFallbackModels();
                gameState.assetsLoaded = true;
            }
        }
        
        // Fallback models if GLB files aren't available
        function createFallbackModels() {
            gameState.carModels.player = createFallbackCar(0x2196F3, true); // Blue, rotated
            gameState.carModels.enemy = createFallbackCar(0xFF4444, true); // Red, rotated
            gameState.carModels.npc = createFallbackCar(0x44FF44, true);   // Green, rotated
        }
        
        function createFallbackCar(color, rotated = false) {
            const group = new THREE.Group();
            
            if (rotated) {
                group.rotation.y = Math.PI; // Rotate 180 degrees for taillights view
            }
            
            // Car body
            const bodyGeometry = new THREE.BoxGeometry(2.5, 1, 4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.5,
                metalness: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 0.5;
            group.add(body);
            
            // Roof
            const roofGeometry = new THREE.BoxGeometry(1.8, 0.5, 2);
            const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
            roof.position.y = 1.25;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            const wheelPositions = [
                [-1, -0.2, 1.2],
                [1, -0.2, 1.2],
                [-1, -0.2, -1.2],
                [1, -0.2, -1.2]
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.castShadow = true;
                wheel.receiveShadow = true;
                group.add(wheel);
            });
            
            // Front lights (now taillights since car is rotated)
            const lightGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({ 
                color: rotated ? 0xFF0000 : 0xFFFF00 // Red taillights when rotated, yellow headlights otherwise
            });
            
            const leftLight = new THREE.Mesh(lightGeometry, lightMaterial);
            leftLight.position.set(-0.8, 0.5, 1.8);
            group.add(leftLight);
            
            const rightLight = new THREE.Mesh(lightGeometry, lightMaterial);
            rightLight.position.set(0.8, 0.5, 1.8);
            group.add(rightLight);
            
            // Add front headlights when rotated (facing backward in world)
            if (rotated) {
                const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                const frontLeftLight = new THREE.Mesh(lightGeometry, headlightMaterial);
                frontLeftLight.position.set(-0.8, 0.5, -1.8);
                group.add(frontLeftLight);
                
                const frontRightLight = new THREE.Mesh(lightGeometry, headlightMaterial);
                frontRightLight.position.set(0.8, 0.5, -1.8);
                group.add(frontRightLight);
            }
            
            return group;
        }
        
        // Initialize the game
        async function init() {
            updateLoading("Setting up 3D scene...", 10);
            
            // Load assets first
            await loadAssets();
            
            // Scene setup
            scene = new THREE.Scene();
            
            // Atmospheric fog that matches horizon
            scene.fog = new THREE.Fog(CONFIG.FOG_COLOR, 200, 1000);
            
            // Camera setup with smaller near clipping plane to fix Z-fighting
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 12, 25); // Behind and above the road
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('roadCanvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = true;
            renderer.autoClear = false;
            
            // Create skybox (blue sky with clouds)
            createSkybox();
            
            // Enhanced Lighting with proper shadow contact
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Sunlight (DirectionalLight) - adjusted for better shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(30, 50, 30);
            directionalLight.castShadow = true;
            
            // Optimized shadow settings for contact shadows
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            
            // Critical: Adjust shadow bias for proper contact
            directionalLight.shadow.bias = -0.001; // Negative bias helps with contact
            directionalLight.shadow.normalBias = 0.02; // Helps with shadow acne
            
            scene.add(directionalLight);
            
            // Additional fill light from front
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(0, 20, 30);
            scene.add(fillLight);
            
            updateLoading("Creating road...", 85);
            
            // Create road with texture and proper lane markings
            createTexturedRoad();
            
            updateLoading("Creating environment...", 90);
            
            // Create natural environment
            createNaturalEnvironment();
            
            updateLoading("Creating cars...", 95);
            
            // Create cars
            createCars();
            
            // Setup event listeners
            setupEventListeners();
            
            updateLoading("Starting game...", 100);
            
            // Hide loading screen after a brief delay
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                animate();
            }, 500);
        }
        
        // ====================
        // SKYBOX CREATION
        // ====================
        function createSkybox() {
            // Create a sky sphere
            const skyGeometry = new THREE.SphereGeometry(2000, 32, 32);
            
            // Create sky material with gradient
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x87CEEB) }, // Sky blue
                    bottomColor: { value: new THREE.Color(0xB0E0E6) }, // Lighter blue
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skybox);
            
            // Add some simple clouds (billboards)
            const cloudGeometry = new THREE.PlaneGeometry(40, 20);
            const cloudMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < 10; i++) {
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(
                    Math.random() * 400 - 200,
                    100 + Math.random() * 50,
                    Math.random() * 600 - 300
                );
                cloud.rotation.y = Math.random() * Math.PI;
                scene.add(cloud);
            }
        }
        
        // ====================
        // ROAD CREATION WITH PROPER LANE MATHEMATICS
        // ====================
        function createTexturedRoad() {
            // Create seamless asphalt texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Asphalt base (darker for realism)
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, 512, 512);
            
            // Add asphalt texture with random grains
            ctx.fillStyle = '#333333';
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 2.5;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(40, 300); // Proper tiling
            
            // Create road geometry - placed at y = 0.01 to prevent Z-fighting
            const roadGeometry = new THREE.PlaneGeometry(
                CONFIG.ROAD_WIDTH, 
                CONFIG.ROAD_LENGTH
            );
            roadGeometry.rotateX(-Math.PI / 2);
            
            const roadMaterial = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.9,
                metalness: 0.0,
                side: THREE.DoubleSide
            });
            
            // Create road mesh - elevated to prevent Z-fighting
            roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.receiveShadow = true;
            roadMesh.position.y = 0.01; // Critical: Slightly above grass
            roadMesh.position.z = -CONFIG.ROAD_LENGTH / 2;
            scene.add(roadMesh);
            
            // Create shoulders (sidewalk area)
            createShoulders();
            
            // Create lane markings - 5 lines total
            createLaneMarkings();
        }
        
        function createShoulders() {
            const shoulderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.9
            });
            
            // Left shoulder
            const leftShoulderGeometry = new THREE.PlaneGeometry(CONFIG.SHOULDER_WIDTH, CONFIG.ROAD_LENGTH);
            leftShoulderGeometry.rotateX(-Math.PI / 2);
            const leftShoulder = new THREE.Mesh(leftShoulderGeometry, shoulderMaterial);
            leftShoulder.position.set(
                -CONFIG.ROAD_WIDTH / 2 - CONFIG.SHOULDER_WIDTH / 2, 
                0.005, // Slightly below road
                -CONFIG.ROAD_LENGTH / 2
            );
            leftShoulder.receiveShadow = true;
            scene.add(leftShoulder);
            
            // Right shoulder
            const rightShoulderGeometry = new THREE.PlaneGeometry(CONFIG.SHOULDER_WIDTH, CONFIG.ROAD_LENGTH);
            rightShoulderGeometry.rotateX(-Math.PI / 2);
            const rightShoulder = new THREE.Mesh(rightShoulderGeometry, shoulderMaterial);
            rightShoulder.position.set(
                CONFIG.ROAD_WIDTH / 2 + CONFIG.SHOULDER_WIDTH / 2, 
                0.005, // Slightly below road
                -CONFIG.ROAD_LENGTH / 2
            );
            rightShoulder.receiveShadow = true;
            scene.add(rightShoulder);
        }
        
        function createLaneMarkings() {
            const boundaries = getLaneBoundaries();
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            const centerLineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            
            // Solid white lines at edges
            createSolidLine(boundaries.leftSolid, 0.1, lineMaterial);
            createSolidLine(boundaries.rightSolid, 0.1, lineMaterial);
            
            // Dashed lines at 25%, 50%, 75%
            createDashedLine(boundaries.dash25, 0.08, false, lineMaterial);
            createDashedLine(boundaries.dash50, 0.08, true, centerLineMaterial); // Yellow center
            createDashedLine(boundaries.dash75, 0.08, false, lineMaterial);
        }
        
        function createSolidLine(xPosition, width, material) {
            const points = [];
            const segmentLength = 100;
            const segments = CONFIG.ROAD_LENGTH / segmentLength;
            
            for (let i = 0; i <= segments; i++) {
                points.push(new THREE.Vector3(
                    xPosition,
                    0.02, // Slightly above road
                    -CONFIG.ROAD_LENGTH / 2 + i * segmentLength
                ));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }
        
        function createDashedLine(xPosition, width, isCenter = false, material) {
            const dashLength = 5;
            const gapLength = 3;
            const dashCount = Math.floor(CONFIG.ROAD_LENGTH / (dashLength + gapLength));
            
            for (let i = 0; i < dashCount; i++) {
                const dashGeometry = new THREE.PlaneGeometry(width, dashLength);
                dashGeometry.rotateX(-Math.PI / 2);
                
                const dashMaterial = isCenter ? 
                    new THREE.MeshBasicMaterial({ color: 0xffff00 }) :
                    new THREE.MeshBasicMaterial({ color: 0xffffff });
                
                const dash = new THREE.Mesh(dashGeometry, dashMaterial);
                
                dash.position.set(
                    xPosition,
                    0.02, // Slightly above road
                    -CONFIG.ROAD_LENGTH / 2 + i * (dashLength + gapLength) + dashLength / 2
                );
                
                scene.add(dash);
            }
        }
        
        // ====================
        // NATURAL ENVIRONMENT
        // ====================
        function createNaturalEnvironment() {
            // Natural olive green grass (desaturated)
            const groundGeometry = new THREE.PlaneGeometry(500, CONFIG.ROAD_LENGTH * 3);
            groundGeometry.rotateX(-Math.PI / 2);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x6B8E23, // Olive green
                roughness: 1.0
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.set(0, 0, 0); // Grass at y=0, road at y=0.01
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add distant hills/mountains for depth
            for (let i = 0; i < 5; i++) {
                createHill(
                    (Math.random() - 0.5) * 300,
                    -800 + i * 400,
                    30 + Math.random() * 40
                );
            }
            
            // Add trees and vegetation
            for (let i = 0; i < 40; i++) {
                // Left side vegetation
                createVegetation(
                    -(CONFIG.ROAD_WIDTH / 2 + CONFIG.SHOULDER_WIDTH + 10 + Math.random() * 30),
                    -CONFIG.ROAD_LENGTH / 2 + i * 75 + Math.random() * 50
                );
                
                // Right side vegetation
                createVegetation(
                    CONFIG.ROAD_WIDTH / 2 + CONFIG.SHOULDER_WIDTH + 10 + Math.random() * 30,
                    -CONFIG.ROAD_LENGTH / 2 + i * 75 + Math.random() * 50
                );
            }
        }
        
        function createHill(x, z, height) {
            const hillGeometry = new THREE.ConeGeometry(80, height, 32);
            const hillMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x556B2F, // Dark olive
                roughness: 0.9
            });
            const hill = new THREE.Mesh(hillGeometry, hillMaterial);
            hill.position.set(x, height / 2, z);
            hill.receiveShadow = true;
            scene.add(hill);
        }
        
        function createVegetation(x, z) {
            const group = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = 2;
            group.add(trunk);
            
            // Foliage
            const foliageGeometry = new THREE.SphereGeometry(3, 8, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2E8B57, // Sea green
                roughness: 0.8
            });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.castShadow = true;
            foliage.receiveShadow = true;
            foliage.position.y = 6;
            group.add(foliage);
            
            group.position.set(x, 0, z);
            scene.add(group);
        }
        
        // ====================
        // CAR CREATION AND ALIGNMENT
        // ====================
        function createCars() {
            if (!gameState.assetsLoaded) return;
            
            // Create player car - properly centered in lane
            gameState.playerCar = gameState.carModels.player.clone();
            snapCarToLaneCenter(gameState.playerCar, gameState.currentLane);
            gameState.playerCar.position.y = 0.5; // Adjusted for proper shadow contact
            gameState.playerCar.position.z = 0;
            
            // Enable shadows for all car parts
            gameState.playerCar.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            scene.add(gameState.playerCar);
        }
        
        function createEnemyCar() {
            if (gameState.enemies.length >= CONFIG.MAX_ENEMIES || !gameState.assetsLoaded) return;
            
            const enemyCar = gameState.carModels.enemy.clone();
            
            // Random lane (0-3)
            const laneIndex = Math.floor(Math.random() * CONFIG.TOTAL_LANES);
            
            // Position behind player with variation
            const distanceBehind = 50 + Math.random() * 80;
            
            // Snap to lane center
            snapCarToLaneCenter(enemyCar, laneIndex);
            enemyCar.position.y = 0.5; // Same height as player for consistency
            enemyCar.position.z = gameState.playerCar.position.z - distanceBehind;
            
            // Enable shadows
            enemyCar.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            enemyCar.userData = {
                lane: laneIndex,
                speed: gameState.speed * (0.7 + Math.random() * 0.6),
                type: 'enemy'
            };
            
            scene.add(enemyCar);
            gameState.enemies.push(enemyCar);
            
            updateUI();
        }
        
        function createNPCCar() {
            if (gameState.npcs.length >= CONFIG.MAX_NPCS || !gameState.assetsLoaded) return;
            
            const npcCar = gameState.carModels.npc.clone();
            
            // Random lane
            const laneIndex = Math.floor(Math.random() * CONFIG.TOTAL_LANES);
            
            // Position behind player
            const distanceBehind = 40 + Math.random() * 120;
            
            // Snap to lane center
            snapCarToLaneCenter(npcCar, laneIndex);
            npcCar.position.y = 0.5;
            npcCar.position.z = gameState.playerCar.position.z - distanceBehind;
            
            // Enable shadows
            npcCar.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            npcCar.userData = {
                lane: laneIndex,
                speed: gameState.speed * (0.4 + Math.random() * 0.7),
                type: 'npc'
            };
            
            scene.add(npcCar);
            gameState.npcs.push(npcCar);
        }
        
        // ====================
        // UPDATE FUNCTIONS
        // ====================
        function updatePlayer(delta) {
            if (!gameState.playerCar || gameState.gameOver) return;
            
            // Move player forward (negative Z direction) - car faces negative Z after rotation
            gameState.playerCar.position.z -= gameState.speed * delta;
            
            // Update lane position with smooth interpolation
            updatePlayerLane();
            
            // Update distance and score
            gameState.distance += gameState.speed * delta;
            gameState.score = Math.floor(gameState.distance / 10);
            
            // Reset position when reaching end of road segment (endless road)
            if (gameState.playerCar.position.z < -CONFIG.ROAD_LENGTH / 2) {
                const resetAmount = CONFIG.ROAD_LENGTH / 2;
                gameState.playerCar.position.z += resetAmount;
                
                // Move enemies
                gameState.enemies.forEach(enemy => {
                    enemy.position.z += resetAmount;
                });
                
                // Move NPCs
                gameState.npcs.forEach(npc => {
                    npc.position.z += resetAmount;
                });
            }
            
            updateUI();
        }
        
        function updatePlayerLane() {
            const currentX = gameState.playerCar.position.x;
            const targetX = getLaneCenter(gameState.targetLane);
            
            if (Math.abs(currentX - targetX) > 0.01) {
                const newX = THREE.MathUtils.lerp(currentX, targetX, CONFIG.LANE_CHANGE_SPEED);
                gameState.playerCar.position.x = newX;
            } else {
                gameState.currentLane = gameState.targetLane;
                updateUI();
            }
        }
        
        function updateEnemies(delta) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Simple AI: occasionally change lanes
                if (Math.random() < 0.003) {
                    const newLane = Math.floor(Math.random() * CONFIG.TOTAL_LANES);
                    enemy.userData.lane = newLane;
                }
                
                // Move toward target lane center
                const currentX = enemy.position.x;
                const targetX = getLaneCenter(enemy.userData.lane);
                
                if (Math.abs(currentX - targetX) > 0.1) {
                    const newX = THREE.MathUtils.lerp(currentX, targetX, 0.04);
                    enemy.position.x = newX;
                }
                
                // Move enemy forward (negative Z)
                enemy.position.z -= enemy.userData.speed * delta;
                
                // Try to match player speed
                enemy.userData.speed += (gameState.speed - enemy.userData.speed) * 0.01;
                
                // Remove enemies that are far behind
                if (enemy.position.z < gameState.playerCar.position.z - 300) {
                    scene.remove(enemy);
                    gameState.enemies.splice(i, 1);
                    updateUI();
                }
                
                // Check collision with player
                if (checkCollision(gameState.playerCar, enemy)) {
                    gameOver();
                }
            }
        }
        
        function updateNPCs(delta) {
            for (let i = gameState.npcs.length - 1; i >= 0; i--) {
                const npc = gameState.npcs[i];
                
                // Move NPC forward
                npc.position.z -= npc.userData.speed * delta;
                
                // Keep NPC centered in lane
                const currentX = npc.position.x;
                const targetX = getLaneCenter(npc.userData.lane);
                
                if (Math.abs(currentX - targetX) > 0.1) {
                    const newX = THREE.MathUtils.lerp(currentX, targetX, 0.02);
                    npc.position.x = newX;
                }
                
                // Remove NPCs that are far behind
                if (npc.position.z < gameState.playerCar.position.z - 350) {
                    scene.remove(npc);
                    gameState.npcs.splice(i, 1);
                }
                
                // Check collision with player
                if (checkCollision(gameState.playerCar, npc)) {
                    gameState.speed = Math.max(10, gameState.speed * 0.6);
                    scene.remove(npc);
                    gameState.npcs.splice(i, 1);
                    updateUI();
                }
            }
        }
        
        function checkCollision(car1, car2) {
            const dx = car1.position.x - car2.position.x;
            const dz = car1.position.z - car2.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            return distance < 3.0; // Collision threshold
        }
        
        function updateCamera() {
            if (!gameState.playerCar) return;
            
            // Third-person camera behind and above the car
            const cameraDistance = 20 + (gameState.speed / 20);
            const cameraHeight = 8 + (gameState.speed / 30);
            
            camera.position.x = gameState.playerCar.position.x * 0.1; // Smooth following
            camera.position.y = cameraHeight;
            camera.position.z = gameState.playerCar.position.z + cameraDistance;
            
            // Look at a point ahead of the car
            const lookAheadDistance = 15 + (gameState.speed / 15);
            camera.lookAt(
                gameState.playerCar.position.x,
                gameState.playerCar.position.y + 2,
                gameState.playerCar.position.z - lookAheadDistance
            );
        }
        
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('speed').textContent = `${Math.round(gameState.speed)} km/h`;
            document.getElementById('distance').textContent = `${Math.round(gameState.distance)} m`;
            document.getElementById('enemies').textContent = gameState.enemies.length;
            document.getElementById('lane').textContent = gameState.currentLane + 1;
            
            // Update speed bar
            const speedPercent = (gameState.speed / CONFIG.MAX_SPEED) * 100;
            document.getElementById('speedFill').style.width = `${Math.min(speedPercent, 100)}%`;
        }
        
        function spawnCars() {
            const now = Date.now();
            
            // Spawn enemies
            if (now - gameState.lastEnemySpawn > CONFIG.ENEMY_SPAWN_INTERVAL) {
                createEnemyCar();
                gameState.lastEnemySpawn = now;
                
                // Increase spawn rate with score
                CONFIG.ENEMY_SPAWN_INTERVAL = Math.max(800, 2500 - gameState.score * 8);
            }
            
            // Spawn NPCs
            if (now - gameState.lastNPCSpawn > CONFIG.NPC_SPAWN_INTERVAL) {
                createNPCCar();
                gameState.lastNPCSpawn = now;
            }
        }
        
        // ====================
        // INPUT HANDLING
        // ====================
        function setupEventListeners() {
            // Keyboard input
            document.addEventListener('keydown', (e) => {
                if (gameState.gameOver) return;
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                    case 'arrowleft':
                        gameState.targetLane = Math.max(0, gameState.targetLane - 1);
                        break;
                    case 'd':
                    case 'arrowright':
                        gameState.targetLane = Math.min(CONFIG.TOTAL_LANES - 1, gameState.targetLane + 1);
                        break;
                    case 'w':
                    case 'arrowup':
                        gameState.speed = Math.min(CONFIG.MAX_SPEED, gameState.speed + 5);
                        break;
                    case 's':
                    case 'arrowdown':
                        gameState.speed = Math.max(10, gameState.speed - 5);
                        break;
                }
            });
            
            // Gamepad support
            window.addEventListener('gamepadconnected', (e) => {
                console.log('Gamepad connected:', e.gamepad.id);
                gameState.gamepad = e.gamepad;
            });
            
            window.addEventListener('gamepaddisconnected', () => {
                gameState.gamepad = null;
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function updateGamepadInput() {
            if (!gameState.gamepad) return;
            
            const gamepad = navigator.getGamepads()[gameState.gamepad.index];
            if (!gamepad) return;
            
            // Left stick for lane changes
            const stickX = gamepad.axes[0];
            if (stickX < -0.5) {
                gameState.targetLane = Math.max(0, gameState.targetLane - 1);
            } else if (stickX > 0.5) {
                gameState.targetLane = Math.min(CONFIG.TOTAL_LANES - 1, gameState.targetLane + 1);
            }
            
            // Right trigger for acceleration
            const acceleration = gamepad.buttons[7].value;
            if (acceleration > 0.1) {
                gameState.speed = Math.min(CONFIG.MAX_SPEED, gameState.speed + acceleration * 3);
            }
            
            // Left trigger for brake
            const brake = gamepad.buttons[6].value;
            if (brake > 0.1) {
                gameState.speed = Math.max(10, gameState.speed - brake * 3);
            }
        }
        
        // ====================
        // GAME FLOW
        // ====================
        function gameOver() {
            gameState.gameOver = true;
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalDistance').textContent = `${Math.round(gameState.distance)} m`;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            // Reset game state
            gameState = {
                score: 0,
                distance: 0,
                speed: CONFIG.INITIAL_SPEED,
                currentLane: 2,
                targetLane: 2,
                gameOver: false,
                playerCar: gameState.playerCar,
                enemies: [],
                npcs: [],
                lastEnemySpawn: 0,
                lastNPCSpawn: 0,
                gamepad: gameState.gamepad,
                assetsLoaded: true,
                carModels: gameState.carModels
            };
            
            // Remove all cars from scene except player
            gameState.enemies.forEach(enemy => scene.remove(enemy));
            gameState.npcs.forEach(npc => scene.remove(npc));
            
            // Reset player car position
            if (gameState.playerCar) {
                snapCarToLaneCenter(gameState.playerCar, gameState.currentLane);
                gameState.playerCar.position.y = 0.5;
                gameState.playerCar.position.z = 0;
            }
            
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            updateUI();
        }
        
        // ====================
        // ANIMATION LOOP
        // ====================
        function animate() {
            if (gameState.gameOver) return;
            
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            
            // Update gamepad input
            updateGamepadInput();
            
            // Spawn new cars
            spawnCars();
            
            // Update game objects
            updatePlayer(delta);
            updateEnemies(delta);
            updateNPCs(delta);
            updateCamera();
            
            // Render
            renderer.render(scene, camera);
        }
        
        // ====================
        // START THE GAME
        // ====================
        init().catch(console.error);
        
        // Make restartGame available globally
        window.restartGame = restartGame;
    </script>
</body>
</html>
