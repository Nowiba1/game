<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless 3D Driving Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
    </style>
    <!-- Three.js core -->
    <script defer src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
    <!-- GLTFLoader -->
    <script defer src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div id="ui">Score: <span id="score">0</span><br>Use ← → or A D to change lanes<br>Gamepad supported</div>

    <script defer>
        // ==================== THREE.JS SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);
        scene.fog = new THREE.FogExp2(0x88ccff, 0.0008);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // ==================== ROAD GENERATION (CatmullRomCurve3) ====================
        const ROAD_WIDTH = 12;
        const LANE_CENTERS = [-4.5, -1.5, 1.5, 4.5];

        let curve;
        let controlPoints = [];
        const SEGMENT_LENGTH = 30;
        const SEGMENTS_AHEAD = 30;
        const SEGMENTS_BEHIND = 10;

        let roadMesh;
        let roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

        function generateInitialCurve() {
            controlPoints = [];
            for (let i = 0; i < SEGMENTS_AHEAD + SEGMENTS_BEHIND; i++) {
                const t = i * SEGMENT_LENGTH;
                const point = new THREE.Vector3(
                    randomTurn(i),
                    randomElevation(i),
                    -t
                );
                controlPoints.push(point);
            }
            curve = new THREE.CatmullRomCurve3(controlPoints);
            curve.curveType = 'centripetal';
            curve.tension = 0.5;
            createRoadMesh();
        }

        function randomTurn(index) {
            if (index % 20 === 0) {
                return (Math.random() < 0.5 ? 1 : -1) * (Math.random() < 0.7 ? 2 : 5);
            }
            return 0;
        }

        function randomElevation(index) {
            return Math.sin(index * 0.1) * 2.5;
        }

        function addSpeedBump(startIndex) {
            for (let i = 0; i < 3; i++) {
                const idx = startIndex + i;
                if (controlPoints[idx]) {
                    controlPoints[idx].y += Math.sin(i * Math.PI / 3) * 1.5;
                }
            }
        }

        function extendCurve() {
            const lastPoint = controlPoints[controlPoints.length - 1].clone();
            const newIndex = controlPoints.length;

            if (newIndex % 40 === 0) {
                addSpeedBump(newIndex);
            }

            const newPoint = new THREE.Vector3(
                lastPoint.x + randomTurn(newIndex),
                randomElevation(newIndex),
                lastPoint.z - SEGMENT_LENGTH
            );
            controlPoints.push(newPoint);
            curve.points.push(newPoint);
            createRoadMesh();
        }

        function createRoadMesh() {
            if (roadMesh) {
                roadMesh.geometry.dispose();
                scene.remove(roadMesh);
            }
            const tubeGeometry = new THREE.TubeGeometry(curve, 512, ROAD_WIDTH / 2, 16, false);
            roadMesh = new THREE.Mesh(tubeGeometry, roadMaterial);
            roadMesh.receiveShadow = true;
            roadMesh.castShadow = true;
            scene.add(roadMesh);
        }

        generateInitialCurve();

        // ==================== PLAYER CAR (fallback box if no model) ====================
        let playerCar;
        let playerLane = 2;
        let targetLane = 2;
        let speed = 0;
        const MAX_SPEED = 1.2;
        const ACCELERATION = 0.002;

        const gltfLoader = new THREE.GLTFLoader();

        // Pour tester sans modèles externes, on utilise une simple boîte
        const fallbackCar = new THREE.Mesh(
            new THREE.BoxGeometry(2, 1.5, 4),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
        );
        fallbackCar.castShadow = true;
        playerCar = fallbackCar;
        playerCar.position.set(LANE_CENTERS[playerLane], 1, 0);
        scene.add(playerCar);

        // ==================== CONTROLS ====================
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        let gamepadIndex = null;
        window.addEventListener('gamepadconnected', e => gamepadIndex = e.gamepad.index);

        function handleInput() {
            let left = keys['a'] || keys['arrowleft'];
            let right = keys['d'] || keys['arrowright'];

            if (gamepadIndex !== null) {
                const gp = navigator.getGamepads()[gamepadIndex];
                if (gp && Math.abs(gp.axes[0]) > 0.3) {
                    if (gp.axes[0] < 0) left = true;
                    if (gp.axes[0] > 0) right = true;
                }
            }

            if (left && targetLane > 0) targetLane--;
            if (right && targetLane < 3) targetLane++;
        }

        // ==================== SIMPLE BUILDINGS ====================
        const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x8888aa });
        for (let i = 0; i < 30; i++) {
            const pos = curve.getPoint(Math.random());
            const offset = (Math.random() > 0.5 ? 1 : -1) * (ROAD_WIDTH / 2 + 10 + Math.random() * 30);
            const height = 10 + Math.random() * 40;
            const building = new THREE.Mesh(
                new THREE.BoxGeometry(10, height, 10),
                buildingMaterial
            );
            building.position.set(pos.x + offset, height / 2, pos.z);
            building.castShadow = true;
            scene.add(building);
        }

        // ==================== GAME LOOP ====================
        let score = 0;
        const scoreElement = document.getElementById('score');

        function animate(time) {
            handleInput();

            if (playerCar) {
                speed = Math.min(speed + ACCELERATION, MAX_SPEED);

                const distanceTraveled = speed * 0.016; // approx 60fps
                const t = -playerCar.position.z / (SEGMENTS_AHEAD * SEGMENT_LENGTH);
                const pos = curve.getPoint(t + distanceTraveled);
                const tangent = curve.getTangent(t + distanceTraveled).normalize();

                playerCar.position.copy(pos);
                playerCar.position.y += 1;

                // Smooth lane change
                playerCar.position.x = THREE.MathUtils.lerp(playerCar.position.x, LANE_CENTERS[targetLane], 0.15);

                // Rotation
                playerCar.lookAt(pos.clone().add(tangent));

                // Camera third-person
                const camOffset = new THREE.Vector3(0, 7, 14);
                camOffset.applyQuaternion(playerCar.quaternion);
                camera.position.copy(playerCar.position).add(camOffset);
                camera.lookAt(playerCar.position.clone().add(tangent.multiplyScalar(15)));

                // Extend road
                if (-playerCar.position.z > (controlPoints.length - SEGMENTS_AHEAD - 10) * SEGMENT_LENGTH) {
                    extendCurve();
                }

                score += speed * 10;
                scoreElement.textContent = Math.floor(score);
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        requestAnimationFrame(animate);
    </script>
</body>
</html>
