<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless 3D Driving Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <div id="ui">Score: <span id="score">0</span><br>Use ← → or A D to change lanes<br>Gamepad supported</div>
    <script>
        // ==================== THREE.JS SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);
        scene.fog = new THREE.FogExp2(0x88ccff, 0.0008);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // ==================== ROAD GENERATION (CatmullRomCurve3) ====================
        // The road is one continuous smooth curve defined by control points.
        // We generate new segments ahead and remove old ones behind the player.
        const ROAD_WIDTH = 12;
        const LANE_WIDTH = ROAD_WIDTH / 4;
        const LANE_CENTERS = [-4.5, -1.5, 1.5, 4.5]; // Fixed lane centers relative to road center

        let curve; // The main CatmullRomCurve3
        let controlPoints = []; // Array of THREE.Vector3
        const SEGMENT_LENGTH = 30; // Distance between control points
        const SEGMENTS_AHEAD = 30; // How many segments to keep ahead
        const SEGMENTS_BEHIND = 10; // How many to keep behind before disposing

        let roadMesh;
        let roadGeometry;
        let roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

        function generateInitialCurve() {
            controlPoints = [];
            for (let i = 0; i < SEGMENTS_AHEAD + SEGMENTS_BEHIND; i++) {
                const t = i * SEGMENT_LENGTH;
                const point = new THREE.Vector3(
                    0 + randomTurn(i),
                    randomElevation(i),
                    -t
                );
                controlPoints.push(point);
            }
            curve = new THREE.CatmullRomCurve3(controlPoints);
            curve.curveType = 'centripetal';
            curve.tension = 0.5;
            createRoadMesh();
        }

        function randomTurn(index) {
            // Easy and hard turns (±2 or ±5 horizontal offset over several segments)
            if (index % 20 === 0) {
                return (Math.random() < 0.5 ? 1 : -1) * (Math.random() < 0.7 ? 2 : 5);
            }
            return 0;
        }

        function randomElevation(index) {
            // Smooth hills and dips (±2.5 units)
            return Math.sin(index * 0.1) * 2.5;
        }

        function addSpeedBump(startIndex) {
            // Add a visible speed bump over 3 segments
            for (let i = 0; i < 3; i++) {
                const idx = startIndex + i;
                if (controlPoints[idx]) {
                    controlPoints[idx].y += Math.sin(i * Math.PI / 2) * 1.2; // Smooth bump shape
                }
            }
        }

        function extendCurve() {
            const lastPoint = controlPoints[controlPoints.length - 1].clone();
            const newIndex = controlPoints.length;

            // Occasionally add speed bump
            if (newIndex % 40 === 0) {
                addSpeedBump(newIndex);
            }

            const newPoint = new THREE.Vector3(
                lastPoint.x + randomTurn(newIndex),
                randomElevation(newIndex),
                lastPoint.z - SEGMENT_LENGTH
            );
            controlPoints.push(newPoint);
            curve.points.push(newPoint);

            // Remove old points and geometry if too far behind
            if (controlPoints.length > SEGMENTS_AHEAD + SEGMENTS_BEHIND + 20) {
                controlPoints.shift();
                curve.points.shift();
                createRoadMesh(); // Regenerate full mesh (simple for performance)
            } else {
                createRoadMesh();
            }
        }

        function createRoadMesh() {
            if (roadGeometry) roadGeometry.dispose();
            if (roadMesh) scene.remove(roadMesh);

            const tubeGeometry = new THREE.TubeGeometry(curve, 512, ROAD_WIDTH / 2, 16, false);
            roadMesh = new THREE.Mesh(tubeGeometry, roadMaterial);
            roadMesh.receiveShadow = true;
            roadMesh.castShadow = true;
            scene.add(roadMesh);
        }

        generateInitialCurve();

        // ==================== ASSET AUTO-DETECTION ====================
        // In a real environment, we would list files in /models/.
        // Since this is a single HTML file, we define available models here.
        // You must place your .glb files at these exact paths relative to the HTML file.
        const MODEL_BASE = 'https://raw.githubusercontent.com/grok-examples/models/main/'; // Replace with your actual host if needed

        const availableModels = [
            'player_car1.glb',
            'player_racing.glb',
            'enemy_car1.glb',
            'enemy_fast.glb',
            'npc_sedan.glb',
            'npc_truck.glb'
        ];

        let playerModels = [];
        let enemyModels = [];
        let npcModels = [];

        availableModels.forEach(name => {
            const lower = name.toLowerCase();
            if (lower.includes('player')) playerModels.push(MODEL_BASE + name);
            else if (lower.includes('enemy')) enemyModels.push(MODEL_BASE + name);
            else if (lower.includes('npc')) npcModels.push(MODEL_BASE + name);
        });

        if (playerModels.length === 0) playerModels = [MODEL_BASE + 'player_car1.glb']; // fallback

        const gltfLoader = new THREE.GLTFLoader();

        // ==================== PLAYER CAR ====================
        let playerCar;
        let playerLane = 2; // Start in lane index 2 (1.5)
        let targetLane = 2;
        let speed = 0;
        const MAX_SPEED = 1.2;
        const ACCELERATION = 0.002;

        function loadRandomModel(urls, callback) {
            const url = urls[Math.floor(Math.random() * urls.length)];
            gltfLoader.load(url, gltf => {
                const model = gltf.scene;
                model.scale.set(1,1,1);
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                callback(model);
            }, undefined, err => console.error('Load error', err));
        }

        loadRandomModel(playerModels, model => {
            playerCar = model;
            playerCar.position.set(LANE_CENTERS[playerLane], 1, 0);
            scene.add(playerCar);
        });

        // ==================== OTHER CARS (ENEMIES & NPCs) ====================
        const otherCars = [];

        function spawnOtherCar() {
            const isEnemy = Math.random() < 0.4 + score * 0.0001; // More enemies over time
            const models = isEnemy ? enemyModels : npcModels;
            if (models.length === 0) return;

            loadRandomModel(models, model => {
                model.position.set(
                    LANE_CENTERS[Math.floor(Math.random() * 4)],
                    1,
                    playerCar ? playerCar.position.z - 100 - Math.random() * 100 : -200
                );
                model.userData = {
                    lane: model.position.x / LANE_WIDTH + 1.5, // approximate
                    speed: 0.6 + Math.random() * 0.4 + (isEnemy ? 0.3 : 0),
                    isEnemy
                };
                scene.add(model);
                otherCars.push(model);
            });
        }

        // Spawn initial cars
        for (let i = 0; i < 8; i++) spawnOtherCar();

        // ==================== CONTROLS ====================
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // Gamepad support
        let gamepadIndex = null;
        window.addEventListener('gamepadconnected', e => gamepadIndex = e.gamepad.index);

        function handleInput() {
            let left = keys['a'] || keys['arrowleft'];
            let right = keys['d'] || keys['arrowright'];

            if (gamepadIndex !== null) {
                const gp = navigator.getGamepads()[gamepadIndex];
                if (gp) {
                    const axis = gp.axes[0];
                    if (axis < -0.5) left = true;
                    if (axis > 0.5) right = true;
                }
            }

            if (left && targetLane > 0) targetLane--;
            if (right && targetLane < 3) targetLane++;
        }

        // ==================== BUILDINGS (simple procedural) ====================
        const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x8888aa });
        function addBuildings() {
            for (let i = 0; i < 20; i++) {
                const pos = curve.getPoint(Math.random());
                const offset = (Math.random() > 0.5 ? 1 : -1) * (ROAD_WIDTH / 2 + 5 + Math.random() * 20);
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(8 + Math.random() * 10, 10 + Math.random() * 30, 8 + Math.random() * 10),
                    buildingMaterial
                );
                building.position.set(pos.x + offset, building.geometry.parameters.height / 2, pos.z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
            }
        }
        addBuildings();

        // ==================== GAME LOOP ====================
        let lastTime = 0;
        let score = 0;
        const scoreElement = document.getElementById('score');

        function animate(time) {
            if (!lastTime) lastTime = time;
            const delta = time - lastTime;
            lastTime = time;

            handleInput();

            if (playerCar) {
                // Accelerate
                speed = Math.min(speed + ACCELERATION, MAX_SPEED);

                // Move player forward along curve
                const t = -playerCar.position.z / (SEGMENTS_AHEAD * SEGMENT_LENGTH);
                const pos = curve.getPoint(t + speed * delta / 1000);
                const tangent = curve.getTangent(t + speed * delta / 1000);

                playerCar.position.copy(pos);
                playerCar.position.y += 1; // hover above road

                // Smooth lane change
                const targetX = LANE_CENTERS[targetLane];
                playerCar.position.x = THREE.MathUtils.lerp(playerCar.position.x, targetX, 0.1);

                // Rotate car to follow road direction
                playerCar.lookAt(pos.clone().add(tangent));

                // Update camera (third-person)
                const cameraOffset = new THREE.Vector3(0, 8, 15);
                cameraOffset.applyQuaternion(playerCar.quaternion);
                camera.position.copy(playerCar.position).add(cameraOffset);
                camera.lookAt(playerCar.position.clone().add(tangent.multiplyScalar(10)));

                // Extend road if needed
                if (-playerCar.position.z > (controlPoints.length - SEGMENTS_AHEAD - 5) * SEGMENT_LENGTH) {
                    extendCurve();
                }

                // Update score
                score += speed * delta / 20;
                scoreElement.textContent = Math.floor(score);

                // Spawn new cars occasionally
                if (Math.random() < 0.02) spawnOtherCar();

                // Update other cars
                otherCars.forEach(car => {
                    const carT = -car.position.z / (SEGMENTS_AHEAD * SEGMENT_LENGTH);
                    const carPos = curve.getPoint(carT + car.userData.speed * delta / 1000);
                    const carTangent = curve.getTangent(carT + car.userData.speed * delta / 1000);

                    car.position.copy(carPos);
                    car.position.y += 1;
                    car.lookAt(carPos.clone().add(carTangent));

                    // Simple lane change for enemies
                    if (car.userData.isEnemy && Math.random() < 0.001) {
                        const newLane = Math.max(0, Math.min(3, car.userData.lane + (Math.random() < 0.5 ? -1 : 1)));
                        car.position.x = LANE_CENTERS[newLane];
                        car.userData.lane = newLane;
                    }

                    // Basic collision (game over if enemy hits player)
                    if (car.userData.isEnemy) {
                        const dist = car.position.distanceTo(playerCar.position);
                        if (dist < 4) {
                            alert('Game Over! Score: ' + Math.floor(score));
                            location.reload();
                        }
                    }
                });

                // Remove far behind cars
                otherCars = otherCars.filter(car => {
                    if (car.position.z > playerCar.position.z + 100) {
                        scene.remove(car);
                        return false;
                    }
                    return true;
                });
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        requestAnimationFrame(animate);
    </script>
</body>
</html>
