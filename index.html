<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Endless Curve Road Game</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* =========================
   BASIC SETUP
========================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x87ceeb, 50, 500);

const camera = new THREE.PerspectiveCamera(
  75, window.innerWidth / window.innerHeight, 0.1, 1000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* =========================
   LIGHTING
========================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));

const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(50, 100, 50);
scene.add(dirLight);

/* =========================
   ROAD PARAMETERS
========================= */
const ROAD_WIDTH = 12;
const SEGMENT_LENGTH = 20;
const MAX_POINTS = 200;

/* =========================
   CURVE POINTS
========================= */
let points = [];
let zPos = 0;
let xOffset = 0;
let yOffset = 0;

function generatePoint() {
  // Turns
  const turnStrength = Math.random() < 0.3 ? 6 : 2; // hard vs easy
  xOffset += THREE.MathUtils.clamp(
    (Math.random() - 0.5) * turnStrength,
    -8, 8
  );

  // Hills & dips
  yOffset += (Math.random() - 0.5) * 2;
  yOffset = THREE.MathUtils.clamp(yOffset, -6, 6);

  // Speed bumps
  if (Math.random() < 0.1) {
    yOffset += 3;
  }

  zPos -= SEGMENT_LENGTH;

  return new THREE.Vector3(xOffset, yOffset, zPos);
}

// Initial points
for (let i = 0; i < MAX_POINTS; i++) {
  points.push(generatePoint());
}

/* =========================
   ROAD MESH
========================= */
let roadMesh;

function buildRoad() {
  if (roadMesh) {
    roadMesh.geometry.dispose();
    scene.remove(roadMesh);
  }

  const curve = new THREE.CatmullRomCurve3(points);
  curve.curveType = 'catmullrom';
  curve.tension = 0.5;

  const geometry = new THREE.TubeGeometry(
    curve,
    400,
    ROAD_WIDTH / 2,
    16,
    false
  );

  const material = new THREE.MeshStandardMaterial({
    color: 0x333333,
    metalness: 0.1,
    roughness: 0.9
  });

  roadMesh = new THREE.Mesh(geometry, material);
  scene.add(roadMesh);

  return curve;
}

let roadCurve = buildRoad();

/* =========================
   PLAYER CAR
========================= */
const car = new THREE.Mesh(
  new THREE.BoxGeometry(2, 1, 4),
  new THREE.MeshStandardMaterial({ color: 0xff3333 })
);
scene.add(car);

let speed = 0.001;
let distance = 0;
let laneOffset = 0;

/* =========================
   INPUT
========================= */
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

/* =========================
   UPDATE LOOP
========================= */
function update() {
  // Speed
  speed += 0.0000005;
  distance += speed;

  // Lanes
  if (keys['a'] || keys['arrowleft']) laneOffset -= 0.1;
  if (keys['d'] || keys['arrowright']) laneOffset += 0.1;
  laneOffset = THREE.MathUtils.clamp(laneOffset, -ROAD_WIDTH / 3, ROAD_WIDTH / 3);

  // Move along curve
  const t = distance % 1;
  const pos = roadCurve.getPointAt(t);
  const tangent = roadCurve.getTangentAt(t);

  car.position.copy(pos);
  car.position.x += laneOffset;
  car.position.y += 1;

  car.rotation.y = Math.atan2(tangent.x, tangent.z);

  // Camera
  const camOffset = tangent.clone().multiplyScalar(-10);
  camOffset.y += 6;

  camera.position.copy(car.position.clone().add(camOffset));
  camera.lookAt(car.position.clone().add(tangent.multiplyScalar(5)));

  // Extend road
  if (distance > 0.8) {
    distance -= 0.2;

    points.splice(0, 10);
    for (let i = 0; i < 10; i++) {
      points.push(generatePoint());
    }

    roadCurve = buildRoad();
  }
}

/* =========================
   RENDER LOOP
========================= */
function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}
animate();

/* =========================
   RESIZE
========================= */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
