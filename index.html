<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Vehicle Racing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        /* Selection Screen */
        #selectionScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
            transition: opacity 0.5s;
            z-index: 1001;
        }

        .selection-title {
            font-size: 3rem;
            margin-bottom: 2rem;
            color: #ff3300;
            text-shadow: 0 0 20px rgba(255, 51, 0, 0.7);
            text-align: center;
        }

        #vehicleGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1200px;
            margin: 2rem 0;
            padding: 0 2rem;
        }

        .vehicle-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            pointer-events: all;
        }

        .vehicle-card:hover {
            transform: translateY(-5px);
            border-color: #ff3300;
            box-shadow: 0 10px 30px rgba(255, 51, 0, 0.3);
        }

        .vehicle-card.selected {
            border-color: #00ff88;
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
            background: rgba(0, 255, 136, 0.1);
        }

        .vehicle-preview {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .vehicle-name {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: white;
        }

        .vehicle-type {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .vehicle-stats {
            font-size: 0.9rem;
            color: #ccc;
        }

        .stat-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }

        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff3300, #ff9900);
            border-radius: 4px;
        }

        #startButton {
            background: linear-gradient(45deg, #ff3300, #ff9900);
            color: white;
            border: none;
            padding: 1rem 3rem;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 2rem;
            pointer-events: all;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 51, 0, 0.5);
        }

        #startButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Game HUD */
        #gameHUD {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 10px;
            min-width: 200px;
            pointer-events: all;
            display: none;
            border: 1px solid rgba(255, 51, 0, 0.5);
        }

        .hud-title {
            color: #ff3300;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #positionDisplay {
            font-size: 2rem;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #lapDisplay {
            font-size: 1.2rem;
            color: white;
            margin-top: 0.5rem;
        }

        /* Speedometer */
        #speedometer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 10px;
            min-width: 150px;
            display: none;
            border: 1px solid rgba(255, 51, 0, 0.5);
        }

        .speed-value {
            font-size: 2rem;
            font-weight: bold;
            color: #ff3300;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 51, 0, 0.5);
        }

        .speed-label {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* Controls Info */
        #controlsInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 10px;
            font-size: 0.9rem;
            display: none;
            border: 1px solid rgba(255, 51, 0, 0.5);
        }

        .control-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        .control-key {
            background: rgba(255, 51, 0, 0.3);
            padding: 3px 8px;
            border-radius: 4px;
            margin-right: 10px;
            min-width: 60px;
            text-align: center;
            font-weight: bold;
        }

        /* Loading Screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1003;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 51, 0, 0.3);
            border-radius: 50%;
            border-top-color: #ff3300;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.5rem;
            color: white;
        }

        /* Game End Screen */
        #gameEndScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 1002;
        }

        #gameEndScreen.show {
            opacity: 1;
            pointer-events: all;
        }

        .game-end-title {
            font-size: 4rem;
            color: #ff3300;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(255, 51, 0, 0.5);
        }

        .game-end-subtitle {
            font-size: 1.5rem;
            color: white;
            margin-bottom: 2rem;
        }

        .restart-button {
            background: linear-gradient(45deg, #ff3300, #ff9900);
            color: white;
            border: none;
            padding: 1rem 3rem;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 2rem;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 51, 0, 0.5);
        }

        /* Progress Bar */
        .progress-bar {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 1rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff3300, #ff9900);
            width: 0%;
            transition: width 0.3s;
        }

        /* Error Message */
        #errorMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            padding: 2rem;
            border-radius: 10px;
            color: white;
            text-align: center;
            display: none;
            z-index: 1004;
            max-width: 500px;
        }

        /* Debug Info */
        #debugInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 12px;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
            display: none;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .selection-title { font-size: 2rem; }
            #vehicleGrid { grid-template-columns: 1fr; }
            #gameHUD, #speedometer, #controlsInfo {
                font-size: 0.8rem;
                padding: 0.5rem;
            }
            .speed-value { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    
    <div id="uiOverlay">
        <!-- Loading Screen -->
        <div id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading Game...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="loadingProgress"></div>
            </div>
        </div>
        
        <!-- Vehicle Selection Screen -->
        <div id="selectionScreen" style="display: none;">
            <h1 class="selection-title">SELECT YOUR VEHICLE</h1>
            <div id="vehicleGrid"></div>
            <button id="startButton" disabled>START RACE</button>
        </div>
        
        <!-- Game HUD -->
        <div id="gameHUD">
            <div class="hud-title">POSITION</div>
            <div id="positionDisplay">1st</div>
            <div id="lapDisplay">LAP: <span id="currentLap">1</span>/3</div>
        </div>
        
        <!-- Speedometer -->
        <div id="speedometer">
            <div class="speed-value">0</div>
            <div class="speed-label">KM/H</div>
        </div>
        
        <!-- Controls Info -->
        <div id="controlsInfo">
            <div class="control-item">
                <div class="control-key">W / ↑</div>
                <div>Accelerate</div>
            </div>
            <div class="control-item">
                <div class="control-key">S / ↓</div>
                <div>Brake/Reverse</div>
            </div>
            <div class="control-item">
                <div class="control-key">A / ←</div>
                <div>Turn Left</div>
            </div>
            <div class="control-item">
                <div class="control-key">D / →</div>
                <div>Turn Right</div>
            </div>
            <div class="control-item">
                <div class="control-key">SPACE</div>
                <div>Handbrake</div>
            </div>
            <div class="control-item">
                <div class="control-key">SHIFT</div>
                <div>Boost</div>
            </div>
            <div class="control-item">
                <div class="control-key">R</div>
                <div>Reset Car</div>
            </div>
        </div>
        
        <!-- Game End Screen -->
        <div id="gameEndScreen">
            <h1 class="game-end-title">RACE COMPLETE!</h1>
            <div class="game-end-subtitle" id="finalMessage"></div>
            <div id="finalScores"></div>
            <button class="restart-button" onclick="restartGame()">PLAY AGAIN</button>
        </div>
        
        <!-- Error Message -->
        <div id="errorMessage"></div>
        
        <!-- Debug Info -->
        <div id="debugInfo"></div>
    </div>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        class VehicleGame {
            constructor() {
                // Core Three.js
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.controls = null;
                
                // Game state
                this.gameStarted = false;
                this.selectedVehicle = null;
                this.vehicles = [];
                this.bots = [];
                this.playerVehicle = null;
                
                // Physics
                this.clock = new THREE.Clock();
                this.keys = {};
                this.physicsWorld = null;
                
                // Track
                this.trackWidth = 40;
                this.trackLength = 400;
                this.checkpoints = [];
                this.currentCheckpoint = 0;
                
                // Game settings
                this.lapCount = 3;
                this.playerLap = 1;
                this.playerPosition = 1;
                
                // DOM
                this.loadingScreen = document.getElementById('loadingScreen');
                this.selectionScreen = document.getElementById('selectionScreen');
                this.startButton = document.getElementById('startButton');
                this.vehicleGrid = document.getElementById('vehicleGrid');
                this.gameHUD = document.getElementById('gameHUD');
                this.speedometer = document.getElementById('speedometer');
                this.controlsInfo = document.getElementById('controlsInfo');
                this.errorMessage = document.getElementById('errorMessage');
                this.debugInfo = document.getElementById('debugInfo');
                
                this.init();
            }
            
            init() {
                this.setupScene();
                this.setupLights();
                this.setupEventListeners();
                this.loadAssets();
                this.animate();
            }
            
            setupScene() {
                // Renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                // Camera
                this.camera.position.set(0, 15, 30);
                
                // Scene
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 300);
                
                // Track
                this.createTrack();
                
                // Controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enabled = false;
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupLights() {
                // Ambient
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                
                // Sun
                const sun = new THREE.DirectionalLight(0xffffff, 1);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.left = -100;
                sun.shadow.camera.right = 100;
                sun.shadow.camera.top = 100;
                sun.shadow.camera.bottom = -100;
                this.scene.add(sun);
                
                // Back light
                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-50, 50, -50);
                this.scene.add(backLight);
            }
            
            createTrack() {
                // Road surface
                const roadGeometry = new THREE.PlaneGeometry(this.trackWidth, this.trackLength);
                const roadMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.receiveShadow = true;
                this.scene.add(road);
                
                // Road markings
                for (let i = -180; i <= 180; i += 20) {
                    const lineGeometry = new THREE.PlaneGeometry(0.5, 2);
                    const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5 });
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(0, 0.02, i);
                    this.scene.add(line);
                }
                
                // Grass
                const grassGeometry = new THREE.PlaneGeometry(this.trackWidth * 3, this.trackLength);
                const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5a27, roughness: 0.9 });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.y = -0.1;
                this.scene.add(grass);
                
                // Barriers
                const barrierGeometry = new THREE.BoxGeometry(this.trackWidth * 3, 2, 1);
                const barrierMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                
                const barrier1 = new THREE.Mesh(barrierGeometry, barrierMaterial);
                barrier1.position.set(0, 1, -this.trackLength/2);
                barrier1.castShadow = true;
                this.scene.add(barrier1);
                
                const barrier2 = new THREE.Mesh(barrierGeometry, barrierMaterial);
                barrier2.position.set(0, 1, this.trackLength/2);
                barrier2.castShadow = true;
                this.scene.add(barrier2);
                
                // Checkpoints
                for (let i = -180; i <= 180; i += 40) {
                    this.checkpoints.push({
                        position: new THREE.Vector3(0, 0, i),
                        passed: false
                    });
                }
            }
            
            async loadAssets() {
                try {
                    this.updateLoadingProgress(10, 'Loading texture...');
                    
                    // Try different texture paths
                    const texturePaths = ['color.png', './color.png', 'textures/color.png'];
                    let texture = null;
                    
                    for (const path of texturePaths) {
                        try {
                            texture = await new Promise((resolve, reject) => {
                                new THREE.TextureLoader().load(
                                    path,
                                    resolve,
                                    undefined,
                                    () => reject(new Error(`Texture not found at ${path}`))
                                );
                            });
                            if (texture) break;
                        } catch (e) {
                            console.log(`Texture not found at ${path}`);
                        }
                    }
                    
                    if (!texture) {
                        console.log('No texture found, using default colors');
                    }
                    
                    this.updateLoadingProgress(30, 'Loading vehicles...');
                    
                    // Load GLTF/GLB
                    const loader = new GLTFLoader();
                    let gltf;
                    
                    try {
                        gltf = await loader.loadAsync('cars.gltf');
                    } catch (e1) {
                        try {
                            gltf = await loader.loadAsync('cars.glb');
                        } catch (e2) {
                            console.log('No GLTF/GLB found, creating placeholder vehicles');
                            this.createPlaceholderVehicles();
                            this.finishLoading();
                            return;
                        }
                    }
                    
                    this.updateLoadingProgress(70, 'Processing models...');
                    
                    // Extract vehicles from GLTF
                    this.extractVehiclesFromGLTF(gltf.scene, texture);
                    
                    if (this.vehicles.length === 0) {
                        console.log('No vehicles found in model, creating placeholders');
                        this.createPlaceholderVehicles();
                    }
                    
                    console.log(`Loaded ${this.vehicles.length} vehicles`);
                    
                    this.updateLoadingProgress(90, 'Creating UI...');
                    this.finishLoading();
                    
                } catch (error) {
                    console.error('Loading error:', error);
                    this.showError('Failed to load game assets. Creating placeholder vehicles...');
                    this.createPlaceholderVehicles();
                    this.finishLoading();
                }
            }
            
            extractVehiclesFromGLTF(scene, texture) {
                // Clear any existing vehicles
                this.vehicles = [];
                
                // Look for vehicle meshes
                const vehicleCandidates = [];
                scene.traverse((child) => {
                    if (child.isMesh) {
                        // Any mesh could be a vehicle part
                        vehicleCandidates.push(child);
                    }
                });
                
                console.log(`Found ${vehicleCandidates.length} candidate meshes`);
                
                if (vehicleCandidates.length === 0) {
                    return;
                }
                
                // Group meshes by proximity (within 2 units)
                const groups = [];
                const visited = new Set();
                
                for (let i = 0; i < vehicleCandidates.length; i++) {
                    if (visited.has(i)) continue;
                    
                    const group = [vehicleCandidates[i]];
                    visited.add(i);
                    
                    for (let j = i + 1; j < vehicleCandidates.length; j++) {
                        if (visited.has(j)) continue;
                        
                        const distance = vehicleCandidates[i].position.distanceTo(vehicleCandidates[j].position);
                        if (distance < 5) {
                            group.push(vehicleCandidates[j]);
                            visited.add(j);
                        }
                    }
                    
                    groups.push(group);
                }
                
                console.log(`Grouped into ${groups.length} vehicle groups`);
                
                // Create vehicle objects
                groups.forEach((group, index) => {
                    if (index >= 8) return; // Limit to 8 vehicles
                    
                    const vehicleGroup = new THREE.Group();
                    
                    // Clone and add all meshes
                    group.forEach(mesh => {
                        const clone = mesh.clone();
                        
                        // Apply texture if available
                        if (texture && clone.material) {
                            if (Array.isArray(clone.material)) {
                                clone.material.forEach(mat => {
                                    if (mat) {
                                        const newMat = mat.clone();
                                        newMat.map = texture;
                                        newMat.needsUpdate = true;
                                        clone.material = newMat;
                                    }
                                });
                            } else {
                                clone.material = clone.material.clone();
                                clone.material.map = texture;
                                clone.material.needsUpdate = true;
                            }
                        }
                        
                        clone.castShadow = true;
                        clone.receiveShadow = true;
                        vehicleGroup.add(clone);
                    });
                    
                    // Calculate bounds
                    const bbox = new THREE.Box3().setFromObject(vehicleGroup);
                    const size = bbox.getSize(new THREE.Vector3());
                    const center = bbox.getCenter(new THREE.Vector3());
                    
                    // Center the vehicle
                    vehicleGroup.position.sub(center);
                    
                    // Determine vehicle type
                    let type = 'Car';
                    if (size.x > 3 || size.z > 6) type = 'Truck';
                    if (size.y > 2.5) type = 'SUV';
                    if (size.x < 1.5 && size.z < 3) type = 'Sports Car';
                    
                    // Create vehicle object
                    this.vehicles.push({
                        id: index,
                        name: `${type} ${index + 1}`,
                        type: type,
                        mesh: vehicleGroup,
                        size: size,
                        speed: 8 + (Math.random() * 6),
                        handling: 0.6 + (Math.random() * 0.3),
                        acceleration: 0.15 + (Math.random() * 0.1),
                        color: new THREE.Color().setHSL(index / this.vehicles.length, 0.8, 0.5)
                    });
                });
            }
            
            createPlaceholderVehicles() {
                // Create 4 different placeholder vehicles
                const types = [
                    { name: 'Sports Car', scale: [1.5, 0.8, 3.5], color: 0xff3300 },
                    { name: 'SUV', scale: [2, 1.5, 4.5], color: 0x3366ff },
                    { name: 'Truck', scale: [2.5, 2, 6], color: 0x33cc33 },
                    { name: 'Race Car', scale: [1.2, 0.7, 3], color: 0xffcc00 }
                ];
                
                types.forEach((type, index) => {
                    const group = new THREE.Group();
                    
                    // Body
                    const bodyGeometry = new THREE.BoxGeometry(...type.scale);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ 
                        color: type.color,
                        roughness: 0.4,
                        metalness: 0.6
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.castShadow = true;
                    body.receiveShadow = true;
                    group.add(body);
                    
                    // Windows
                    const windowGeometry = new THREE.BoxGeometry(type.scale[0] * 0.8, type.scale[1] * 0.3, type.scale[2] * 0.8);
                    const windowMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x222222,
                        roughness: 0.1,
                        metalness: 1.0,
                        transparent: true,
                        opacity: 0.7
                    });
                    const windows = new THREE.Mesh(windowGeometry, windowMaterial);
                    windows.position.y = type.scale[1] * 0.3;
                    group.add(windows);
                    
                    // Wheels
                    const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 8);
                    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
                    
                    const wheelPositions = [
                        { x: -type.scale[0]/2 + 0.4, y: -type.scale[1]/2, z: type.scale[2]/2 - 0.5 },
                        { x: type.scale[0]/2 - 0.4, y: -type.scale[1]/2, z: type.scale[2]/2 - 0.5 },
                        { x: -type.scale[0]/2 + 0.4, y: -type.scale[1]/2, z: -type.scale[2]/2 + 0.5 },
                        { x: type.scale[0]/2 - 0.4, y: -type.scale[1]/2, z: -type.scale[2]/2 + 0.5 }
                    ];
                    
                    wheelPositions.forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.position.set(pos.x, pos.y, pos.z);
                        wheel.rotation.z = Math.PI / 2;
                        wheel.castShadow = true;
                        group.add(wheel);
                    });
                    
                    this.vehicles.push({
                        id: index,
                        name: type.name,
                        type: type.name,
                        mesh: group,
                        size: new THREE.Vector3(...type.scale),
                        speed: index === 0 ? 12 : index === 3 ? 14 : index === 1 ? 8 : 6,
                        handling: index === 0 ? 0.9 : index === 3 ? 0.95 : index === 1 ? 0.7 : 0.6,
                        acceleration: index === 0 ? 0.2 : index === 3 ? 0.25 : index === 1 ? 0.15 : 0.12,
                        color: new THREE.Color(type.color)
                    });
                });
            }
            
            finishLoading() {
                this.updateLoadingProgress(100, 'Ready!');
                
                setTimeout(() => {
                    this.loadingScreen.style.display = 'none';
                    this.selectionScreen.style.display = 'flex';
                    this.createVehicleSelectionUI();
                }, 500);
            }
            
            updateLoadingProgress(percent, message) {
                const progress = document.getElementById('loadingProgress');
                const text = document.querySelector('.loading-text');
                if (progress) progress.style.width = `${percent}%`;
                if (text) text.textContent = message;
            }
            
            showError(message) {
                this.errorMessage.textContent = message;
                this.errorMessage.style.display = 'block';
                setTimeout(() => {
                    this.errorMessage.style.display = 'none';
                }, 3000);
            }
            
            createVehicleSelectionUI() {
                this.vehicleGrid.innerHTML = '';
                
                this.vehicles.forEach((vehicle, index) => {
                    const card = document.createElement('div');
                    card.className = 'vehicle-card';
                    card.dataset.index = index;
                    
                    const preview = document.createElement('div');
                    preview.className = 'vehicle-preview';
                    preview.id = `preview-${index}`;
                    
                    const name = document.createElement('div');
                    name.className = 'vehicle-name';
                    name.textContent = vehicle.name;
                    
                    const type = document.createElement('div');
                    type.className = 'vehicle-type';
                    type.textContent = vehicle.type;
                    
                    const stats = document.createElement('div');
                    stats.className = 'vehicle-stats';
                    stats.innerHTML = `
                        <div style="margin: 5px 0;">Speed</div>
                        <div class="stat-bar">
                            <div class="stat-fill" style="width: ${(vehicle.speed / 15) * 100}%"></div>
                        </div>
                        <div style="margin: 5px 0;">Handling</div>
                        <div class="stat-bar">
                            <div class="stat-fill" style="width: ${vehicle.handling * 100}%"></div>
                        </div>
                        <div style="margin: 5px 0;">Acceleration</div>
                        <div class="stat-bar">
                            <div class="stat-fill" style="width: ${(vehicle.acceleration / 0.25) * 100}%"></div>
                        </div>
                    `;
                    
                    card.appendChild(preview);
                    card.appendChild(name);
                    card.appendChild(type);
                    card.appendChild(stats);
                    
                    card.addEventListener('click', () => this.selectVehicle(index));
                    this.vehicleGrid.appendChild(card);
                    
                    // Create preview
                    this.createVehiclePreview(index);
                });
                
                this.startButton.disabled = true;
            }
            
            createVehiclePreview(index) {
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
                const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                
                renderer.setSize(300, 200);
                renderer.setClearColor(0x000000, 0);
                
                const container = document.getElementById(`preview-${index}`);
                if (!container) return;
                
                container.appendChild(renderer.domElement);
                
                // Lights
                scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const light = new THREE.DirectionalLight(0xffffff, 0.8);
                light.position.set(10, 10, 5);
                scene.add(light);
                
                // Vehicle
                const vehicle = this.vehicles[index];
                const mesh = vehicle.mesh.clone();
                
                // Center and scale
                const box = new THREE.Box3().setFromObject(mesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                mesh.position.sub(center);
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 3 / maxDim;
                mesh.scale.multiplyScalar(scale);
                
                scene.add(mesh);
                
                // Camera
                camera.position.set(5, 3, 5);
                camera.lookAt(0, 0, 0);
                
                // Animation
                let angle = 0;
                const animate = () => {
                    if (!container.isConnected) {
                        renderer.dispose();
                        return;
                    }
                    
                    angle += 0.01;
                    mesh.rotation.y = angle;
                    
                    renderer.render(scene, camera);
                    requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            selectVehicle(index) {
                document.querySelectorAll('.vehicle-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                const card = document.querySelector(`.vehicle-card[data-index="${index}"]`);
                if (card) card.classList.add('selected');
                
                this.selectedVehicle = index;
                this.startButton.disabled = false;
            }
            
            setupEventListeners() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    this.keys[key] = true;
                    
                    if (key === 'escape') this.togglePause();
                    if (key === 'r' && this.playerVehicle) this.resetPlayer();
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Start button
                this.startButton.addEventListener('click', () => this.startGame());
            }
            
            startGame() {
                if (this.selectedVehicle === null) return;
                
                // Hide selection screen
                this.selectionScreen.style.opacity = '0';
                setTimeout(() => {
                    this.selectionScreen.style.display = 'none';
                }, 500);
                
                // Show game UI
                this.gameHUD.style.display = 'block';
                this.speedometer.style.display = 'block';
                this.controlsInfo.style.display = 'block';
                
                // Initialize game
                this.initializeGame();
                this.gameStarted = true;
            }
            
            initializeGame() {
                // Clear existing
                this.bots.forEach(bot => this.scene.remove(bot.mesh));
                this.bots = [];
                
                // Player vehicle
                const playerData = this.vehicles[this.selectedVehicle];
                this.playerVehicle = this.createGameVehicle(playerData, true);
                this.playerVehicle.mesh.position.set(-10, 1, -180);
                this.playerVehicle.name = "Player";
                this.scene.add(this.playerVehicle.mesh);
                
                // Create bots from other vehicles
                let botCount = 0;
                for (let i = 0; i < this.vehicles.length; i++) {
                    if (i === this.selectedVehicle) continue;
                    if (botCount >= 7) break;
                    
                    const botData = this.vehicles[i];
                    const bot = this.createGameVehicle(botData, false);
                    bot.name = `Bot ${botCount + 1}`;
                    bot.id = botCount;
                    
                    // Position bots in a grid
                    const row = Math.floor(botCount / 3);
                    const col = botCount % 3;
                    bot.mesh.position.set(-8 + (col * 8), 1, -180 + (row * 5));
                    
                    this.scene.add(bot.mesh);
                    this.bots.push(bot);
                    botCount++;
                }
                
                console.log(`Created ${botCount} bots`);
                
                // Setup camera
                this.setupCamera();
                
                // Reset game state
                this.playerLap = 1;
                this.currentCheckpoint = 0;
                this.playerPosition = 1;
                document.getElementById('currentLap').textContent = '1';
                document.getElementById('positionDisplay').textContent = '1st';
            }
            
            createGameVehicle(data, isPlayer) {
                const mesh = data.mesh.clone();
                
                if (isPlayer) {
                    // Make player vehicle green
                    mesh.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    if (mat) {
                                        mat.color.setHex(0x00ff88);
                                        mat.emissive.setHex(0x003322);
                                        mat.emissiveIntensity = 0.3;
                                    }
                                });
                            } else {
                                child.material.color.setHex(0x00ff88);
                                child.material.emissive.setHex(0x003322);
                                child.material.emissiveIntensity = 0.3;
                            }
                        }
                    });
                }
                
                return {
                    mesh: mesh,
                    data: data,
                    velocity: new THREE.Vector3(),
                    rotation: 0,
                    speed: 0,
                    maxSpeed: data.speed * 3,
                    acceleration: data.acceleration,
                    deceleration: 0.2,
                    turnSpeed: data.handling * 0.1,
                    driftFactor: 0.95,
                    isPlayer: isPlayer,
                    lap: 1,
                    checkpoint: 0,
                    boost: 100,
                    isBoosting: false,
                    name: isPlayer ? "Player" : data.name
                };
            }
            
            setupCamera() {
                this.cameraTarget = new THREE.Object3D();
                this.scene.add(this.cameraTarget);
                this.controls.target = this.playerVehicle.mesh.position;
            }
            
            updatePlayer(deltaTime) {
                if (!this.playerVehicle) return;
                
                const vehicle = this.playerVehicle;
                const mesh = vehicle.mesh;
                
                // Boost
                vehicle.isBoosting = this.keys['shift'] && vehicle.boost > 0;
                if (vehicle.isBoosting) {
                    vehicle.boost = Math.max(vehicle.boost - 40 * deltaTime, 0);
                } else if (vehicle.boost < 100) {
                    vehicle.boost = Math.min(vehicle.boost + 20 * deltaTime, 100);
                }
                
                const boostMultiplier = vehicle.isBoosting ? 1.5 : 1;
                
                // Acceleration
                if (this.keys['w'] || this.keys['arrowup']) {
                    vehicle.speed = THREE.MathUtils.lerp(
                        vehicle.speed,
                        vehicle.maxSpeed * boostMultiplier,
                        vehicle.acceleration * deltaTime * 10
                    );
                }
                // Braking
                else if (this.keys['s'] || this.keys['arrowdown']) {
                    vehicle.speed = THREE.MathUtils.lerp(
                        vehicle.speed,
                        -vehicle.maxSpeed * 0.5,
                        vehicle.deceleration * deltaTime * 10
                    );
                }
                // Coasting
                else {
                    vehicle.speed *= 0.98;
                    if (Math.abs(vehicle.speed) < 0.1) vehicle.speed = 0;
                }
                
                // Turning (only when moving)
                if (Math.abs(vehicle.speed) > 0.5) {
                    const turnMultiplier = vehicle.turnSpeed * (1 - Math.abs(vehicle.speed) / vehicle.maxSpeed * 0.7);
                    
                    if (this.keys['a'] || this.keys['arrowleft']) {
                        vehicle.rotation += turnMultiplier * deltaTime * Math.sign(vehicle.speed);
                    }
                    if (this.keys['d'] || this.keys['arrowright']) {
                        vehicle.rotation -= turnMultiplier * deltaTime * Math.sign(vehicle.speed);
                    }
                    
                    // Handbrake/drift
                    if (this.keys[' ']) {
                        vehicle.rotation *= 1.1;
                        vehicle.speed *= vehicle.driftFactor;
                    }
                }
                
                // Smooth rotation
                vehicle.rotation *= 0.9;
                
                // Update position
                mesh.rotation.y = vehicle.rotation;
                const moveSpeed = vehicle.speed * deltaTime;
                
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), vehicle.rotation);
                mesh.position.add(forward.multiplyScalar(moveSpeed));
                
                // Keep on track
                mesh.position.x = THREE.MathUtils.clamp(mesh.position.x, -this.trackWidth/2 + 2, this.trackWidth/2 - 2);
                
                // Check if off track
                if (Math.abs(mesh.position.x) > this.trackWidth/2 - 1) {
                    vehicle.speed *= 0.7; // Slow down when hitting barrier
                }
                
                // Update camera
                this.updateCamera();
                
                // Update speedometer
                const speedKmh = Math.abs(vehicle.speed * 20);
                document.querySelector('.speed-value').textContent = Math.floor(speedKmh);
                
                // Update position display
                this.updatePosition();
            }
            
            updateCamera() {
                if (!this.playerVehicle) return;
                
                const vehicle = this.playerVehicle;
                const mesh = vehicle.mesh;
                
                // Camera follows behind vehicle
                const cameraDistance = 15;
                const cameraHeight = 8;
                
                const behind = new THREE.Vector3(0, 0, cameraDistance);
                behind.applyAxisAngle(new THREE.Vector3(0, 1, 0), mesh.rotation.y);
                
                const targetPos = mesh.position.clone().add(behind);
                targetPos.y = cameraHeight;
                
                this.camera.position.lerp(targetPos, 0.1);
                this.camera.lookAt(mesh.position.x, mesh.position.y + 2, mesh.position.z);
            }
            
            updateBotAI(bot, deltaTime) {
                const mesh = bot.mesh;
                
                // Simple AI: follow the track with some randomness
                const targetX = (Math.random() - 0.5) * 10;
                const xDiff = targetX - mesh.position.x;
                
                // Adjust rotation toward target
                bot.rotation += Math.sign(xDiff) * bot.turnSpeed * deltaTime * 0.5;
                bot.rotation *= 0.95;
                
                // Maintain speed
                const targetSpeed = bot.maxSpeed * (0.6 + Math.random() * 0.3);
                bot.speed = THREE.MathUtils.lerp(bot.speed, targetSpeed, bot.acceleration * deltaTime * 5);
                
                // Update position
                mesh.rotation.y = bot.rotation;
                const moveSpeed = bot.speed * deltaTime;
                
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), bot.rotation);
                mesh.position.add(forward.multiplyScalar(moveSpeed));
                
                // Keep on track
                mesh.position.x = THREE.MathUtils.clamp(mesh.position.x, -this.trackWidth/2 + 2, this.trackWidth/2 - 2);
                
                // Update lap based on position
                if (mesh.position.z > 190 && bot.lap < this.lapCount) {
                    bot.lap++;
                    mesh.position.z = -180;
                }
            }
            
            updatePosition() {
                if (!this.playerVehicle) return;
                
                // Calculate all vehicle progress
                const allVehicles = [
                    { ...this.playerVehicle, progress: (this.playerLap * 1000) + this.playerVehicle.mesh.position.z },
                    ...this.bots.map(bot => ({ ...bot, progress: (bot.lap * 1000) + bot.mesh.position.z }))
                ];
                
                // Sort by progress (higher = better)
                allVehicles.sort((a, b) => b.progress - a.progress);
                
                // Find player position
                const playerIndex = allVehicles.findIndex(v => v.isPlayer);
                this.playerPosition = playerIndex + 1;
                
                // Update display
                const positionText = this.getOrdinal(this.playerPosition);
                document.getElementById('positionDisplay').textContent = positionText;
                document.getElementById('currentLap').textContent = this.playerLap;
                
                // Check for lap completion
                if (this.playerVehicle.mesh.position.z > 190 && this.currentCheckpoint === this.checkpoints.length - 1) {
                    this.playerLap++;
                    this.currentCheckpoint = 0;
                    this.playerVehicle.mesh.position.z = -180;
                    
                    if (this.playerLap > this.lapCount) {
                        this.endGame();
                    }
                }
                
                // Check checkpoints
                this.checkpoints.forEach((checkpoint, index) => {
                    const distance = this.playerVehicle.mesh.position.distanceTo(checkpoint.position);
                    if (distance < 20 && index > this.currentCheckpoint) {
                        this.currentCheckpoint = index;
                    }
                });
            }
            
            getOrdinal(n) {
                const s = ["th", "st", "nd", "rd"];
                const v = n % 100;
                return n + (s[(v - 20) % 10] || s[v] || s[0]);
            }
            
            resetPlayer() {
                if (this.playerVehicle) {
                    this.playerVehicle.mesh.position.set(-10, 1, -180);
                    this.playerVehicle.mesh.rotation.y = 0;
                    this.playerVehicle.speed = 0;
                    this.playerVehicle.rotation = 0;
                    this.playerVehicle.boost = 100;
                }
            }
            
            togglePause() {
                this.gameStarted = !this.gameStarted;
                if (this.gameStarted) {
                    this.animate();
                }
            }
            
            endGame() {
                this.gameStarted = false;
                
                // Calculate final scores
                const allVehicles = [
                    { name: "Player", lap: this.playerLap - 1, position: this.playerPosition, color: '#00ff88' },
                    ...this.bots.map((bot, i) => ({
                        name: bot.name,
                        lap: bot.lap,
                        position: i + (i >= this.playerPosition - 1 ? 2 : 1),
                        color: ['#ff3300', '#3366ff', '#33cc33', '#ffcc00', '#ff66cc', '#66ffff', '#ffff66'][i]
                    }))
                ];
                
                // Sort by lap then position
                allVehicles.sort((a, b) => {
                    if (b.lap !== a.lap) return b.lap - a.lap;
                    return a.position - b.position;
                });
                
                // Show end screen
                const endScreen = document.getElementById('gameEndScreen');
                const finalMessage = document.getElementById('finalMessage');
                const finalScores = document.getElementById('finalScores');
                
                if (this.playerPosition === 1) {
                    finalMessage.textContent = "🏆 VICTORY! 🏆";
                } else if (this.playerPosition <= 3) {
                    finalMessage.textContent = `PODIUM FINISH! ${this.getOrdinal(this.playerPosition)} Place`;
                } else {
                    finalMessage.textContent = `Finished ${this.getOrdinal(this.playerPosition)}`;
                }
                
                // Display scores
                finalScores.innerHTML = '<h3 style="margin: 20px 0; color: #ff9900;">FINAL RESULTS</h3>';
                allVehicles.forEach((vehicle, index) => {
                    const div = document.createElement('div');
                    div.style.cssText = `
                        padding: 10px 20px;
                        margin: 5px 0;
                        background: ${vehicle.position === 1 ? 'rgba(255, 215, 0, 0.2)' : 'rgba(255, 255, 255, 0.1)'};
                        border-radius: 5px;
                        display: flex;
                        align-items: center;
                        border-left: 4px solid ${vehicle.color};
                    `;
                    
                    div.innerHTML = `
                        <div style="font-size: 1.2rem; font-weight: bold; margin-right: 20px; min-width: 30px;">
                            ${index + 1}
                        </div>
                        <div style="flex: 1; font-size: 1.1rem;">${vehicle.name}</div>
                        <div style="color: #ff9900; font-weight: bold;">
                            ${vehicle.lap} Laps
                        </div>
                    `;
                    
                    finalScores.appendChild(div);
                });
                
                endScreen.classList.add('show');
            }
            
            animate() {
                if (!this.gameStarted) return;
                
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = Math.min(this.clock.getDelta(), 0.1);
                
                // Update player
                if (this.playerVehicle) {
                    this.updatePlayer(deltaTime);
                }
                
                // Update bots
                this.bots.forEach(bot => {
                    this.updateBotAI(bot, deltaTime);
                });
                
                // Render
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Initialize game
        window.game = new VehicleGame();
        
        // Global restart function
        window.restartGame = function() {
            // Hide end screen
            document.getElementById('gameEndScreen').classList.remove('show');
            
            // Show selection screen
            document.getElementById('selectionScreen').style.display = 'flex';
            document.getElementById('selectionScreen').style.opacity = '1';
            
            // Hide game UI
            document.getElementById('gameHUD').style.display = 'none';
            document.getElementById('speedometer').style.display = 'none';
            document.getElementById('controlsInfo').style.display = 'none';
            
            // Reset selection
            document.querySelectorAll('.vehicle-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById('startButton').disabled = true;
            window.game.selectedVehicle = null;
        };
    </script>
</body>
</html>
