<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Riders: Delivery Chaos</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial Black', sans-serif; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .stats { position: absolute; top: 20px; left: 20px; color: #0f0; font-size: 20px; text-shadow: 2px 2px #000; }
        #speed-o { position: absolute; bottom: 30px; right: 30px; color: #fff; font-size: 40px; text-align: right; }
        #start-screen { 
            position: absolute; width: 100%; height: 100%; background: #000; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            color: #ffcc00; z-index: 100; pointer-events: all;
        }
        #game-over { 
            position: absolute; width: 100%; height: 100%; background: rgba(255,0,0,0.3); 
            display: none; justify-content: center; align-items: center; flex-direction: column; color: white;
        }
        button { padding: 15px 40px; font-size: 20px; cursor: pointer; background: #ffcc00; border: none; font-weight: bold; }
    </style>
</head>
<body>

<div id="start-screen">
    <h1>CART RIDERS: DELIVERY CHAOS</h1>
    <p>3 LANES. NO BRAKES. TOTAL CHAOS.</p>
    <button id="start-btn">START DELIVERY</button>
</div>

<div id="ui">
    <div class="stats">
        SCORE: <span id="score">0</span><br>
        CARGO: <span id="cargo">10</span>/10<br>
        BOTS: <span id="bots">0</span>
    </div>
    <div id="speed-o"><span id="kmh">0</span> KM/H</div>
</div>

<div id="game-over">
    <h1>DELIVERY FAILED</h1>
    <h2 id="final-score"></h2>
    <button onclick="location.reload()">TRY AGAIN</button>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // --- GAME CONSTANTS ---
    const LANE_WIDTH = 4;
    const SEGMENT_SIZE = 60;
    const VISIBLE_SEGMENTS = 10;
    
    let scene, camera, renderer, clock, player;
    let roadSegments = [];
    let buildings = [];
    let activeBots = [];
    let isRunning = false;
    
    // Player State
    let state = {
        speed: 0,
        lane: 0, // -1, 0, 1
        targetX: 0,
        cargo: 10,
        score: 0,
        lastBotScore: 0
    };

    const inputs = { w: false, s: false, a: false, d: false };

    // --- TEXTURE ENGINE ---
    function createBuildingTex() {
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#333'; ctx.fillRect(0, 0, 256, 512);
        ctx.fillStyle = '#555'; // Window grid
        for(let y=20; y<512; y+=40) {
            for(let x=20; x<256; x+=50) {
                ctx.fillStyle = Math.random() > 0.1 ? '#111' : '#ffaa00';
                ctx.fillRect(x, y, 30, 30);
            }
        }
        return new THREE.CanvasTexture(canvas);
    }

    // --- CORE SETUP ---
    async function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.FogExp2(0x0a0a0a, 0.015);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(10, 20, 10);
        scene.add(sun, new THREE.AmbientLight(0x404040));

        player = new THREE.Group();
        scene.add(player);

        await loadAssets();
        
        // Initial Road
        for(let i=0; i<VISIBLE_SEGMENTS; i++) {
            generateSegment(i * -SEGMENT_SIZE);
        }

        window.addEventListener('keydown', (e) => updateKey(e, true));
        window.addEventListener('keyup', (e) => updateKey(e, false));
        
        clock = new THREE.Clock();
        animate();
    }

    async function loadAssets() {
        const loader = new GLTFLoader();
        const box = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 2.5), new THREE.MeshStandardMaterial({color: 0x555555}));
        const man = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.6), new THREE.MeshStandardMaterial({color: 0xffdbac}));
        
        // TRY LOAD MODELS
        try {
            const cartData = await loader.loadAsync('models/cart1.glb');
            player.add(cartData.scene);
        } catch(e) { player.add(box); } // Fallback to box if models/ folder missing

        try {
            const manData = await loader.loadAsync('models/player1.glb');
            player.add(manData.scene);
            manData.scene.position.y = 0.5;
        } catch(e) { player.add(man); man.position.y = 0.5; }

        player.rotation.y = Math.PI / 4; // 45 degree tilt
    }

    function generateSegment(zPos) {
        const group = new THREE.Group();
        
        // Road surface
        const roadGeo = new THREE.PlaneGeometry(LANE_WIDTH * 3, SEGMENT_SIZE, 1, 5);
        roadGeo.rotateX(-Math.PI/2);
        
        // Create Dips/Bumps
        const pos = roadGeo.attributes.position;
        const elevation = (Math.random() - 0.5) * 4;
        for(let i=0; i<pos.count; i++) {
            if(pos.getZ(i) < -SEGMENT_SIZE/2) pos.setY(i, elevation);
        }

        const road = new THREE.Mesh(roadGeo, new THREE.MeshStandardMaterial({color: 0x111111}));
        group.add(road);

        // Lane markings
        const lineGeo = new THREE.PlaneGeometry(0.2, SEGMENT_SIZE);
        lineGeo.rotateX(-Math.PI/2);
        const lineMat = new THREE.MeshBasicMaterial({color: 0xffffff});
        const l1 = new THREE.Mesh(lineGeo, lineMat); l1.position.set(-LANE_WIDTH/2, 0.05, 0);
        const l2 = new THREE.Mesh(lineGeo, lineMat); l2.position.set(LANE_WIDTH/2, 0.05, 0);
        group.add(l1, l2);

        group.position.z = zPos;
        scene.add(group);
        roadSegments.push({mesh: group, elevation: elevation});

        // Building on sides
        spawnBuilding(zPos);
    }

    function spawnBuilding(z) {
        const h = 15 + Math.random() * 30;
        const geo = new THREE.BoxGeometry(10, h, 10);
        const mat = new THREE.MeshStandardMaterial({map: createBuildingTex()});
        const b = new THREE.Mesh(geo, mat);
        b.position.set(Math.random() > 0.5 ? 15 : -15, h/2, z);
        scene.add(b);
        buildings.push(b);
    }

    // --- GAMEPLAY LOGIC ---
    function updateKey(e, val) {
        if(e.key.toLowerCase() === 'a') { if(val && state.lane > -1) state.lane--; }
        if(e.key.toLowerCase() === 'd') { if(val && state.lane < 1) state.lane++; }
        if(e.key.toLowerCase() === 'w') inputs.w = val;
        if(e.key.toLowerCase() === 's') inputs.s = val;
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!isRunning) return;

        const dt = clock.getDelta();
        
        // Physics
        if(inputs.w) state.speed = THREE.MathUtils.lerp(state.speed, 60, dt * 1);
        else if(inputs.s) state.speed = THREE.MathUtils.lerp(state.speed, -10, dt * 3);
        else state.speed = THREE.MathUtils.lerp(state.speed, 20, dt * 0.5);

        player.position.z -= state.speed * dt;
        state.targetX = state.lane * LANE_WIDTH;
        player.position.x = THREE.MathUtils.lerp(player.position.x, state.targetX, dt * 8);

        // Score & AI Scaling
        state.score += Math.floor(state.speed * dt);
        if(state.score - state.lastBotScore > 1000) {
            spawnBot();
            state.lastBotScore = state.score;
        }

        // Road Recycling
        if(player.position.z < roadSegments[1].mesh.position.z) {
            const old = roadSegments.shift();
            scene.remove(old.mesh);
            generateSegment(roadSegments[roadSegments.length-1].mesh.position.z - SEGMENT_SIZE);
        }

        // Camera
        camera.position.lerp(new THREE.Vector3(player.position.x * 0.5, 6, player.position.z + 10), dt * 5);
        camera.lookAt(player.position.x, 2, player.position.z - 20);

        updateBots(dt);
        updateUI();
        renderer.render(scene, camera);
    }

    function spawnBot() {
        const bot = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 2), new THREE.MeshStandardMaterial({color: 0xff0000}));
        bot.position.set((Math.random()-0.5)*10, 0.5, player.position.z - 100);
        scene.add(bot);
        activeBots.push(bot);
    }

    function updateBots(dt) {
        activeBots.forEach((bot, i) => {
            bot.position.z -= (state.speed + 10) * dt;
            bot.position.x = THREE.MathUtils.lerp(bot.position.x, player.position.x, dt * 0.5);
            
            if(bot.position.distanceTo(player.position) < 2.5) {
                state.cargo--;
                bot.position.z -= 20; 
                if(state.cargo <= 0) { isRunning = false; document.getElementById('game-over').style.display='flex'; }
            }
        });
    }

    function updateUI() {
        document.getElementById('score').innerText = state.score;
        document.getElementById('kmh').innerText = Math.floor(state.speed);
        document.getElementById('cargo').innerText = state.cargo;
        document.getElementById('bots').innerText = activeBots.length;
    }

    document.getElementById('start-btn').onclick = () => {
        document.getElementById('start-screen').style.display = 'none';
        isRunning = true;
    };

    init();
</script>
</body>
</html>
