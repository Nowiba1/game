<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Vehicle Racing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        /* Selection Screen */
        #selectionScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
            transition: opacity 0.5s;
            z-index: 1001;
        }

        .selection-title {
            font-size: 3rem;
            margin-bottom: 2rem;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            text-align: center;
        }

        #vehicleGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1200px;
            margin: 2rem 0;
            padding: 0 2rem;
        }

        .vehicle-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            pointer-events: all;
        }

        .vehicle-card:hover {
            transform: translateY(-10px);
            border-color: #00ff88;
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }

        .vehicle-card.selected {
            border-color: #ff0080;
            box-shadow: 0 10px 30px rgba(255, 0, 128, 0.3);
            background: rgba(255, 0, 128, 0.1);
        }

        .vehicle-preview {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .vehicle-name {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: white;
        }

        .vehicle-type {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .vehicle-stats {
            font-size: 0.9rem;
            color: #ccc;
        }

        #startButton {
            background: linear-gradient(45deg, #ff0080, #ff8c00);
            color: white;
            border: none;
            padding: 1rem 3rem;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 2rem;
            pointer-events: all;
            transition: all 0.3s ease;
        }

        #startButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 128, 0.5);
        }

        #startButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Game HUD */
        #gameHUD {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 10px;
            min-width: 250px;
            pointer-events: all;
            display: none;
        }

        .hud-section {
            margin-bottom: 1rem;
        }

        .hud-title {
            color: #00ff88;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .player-info {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
        }

        .player-info.active {
            background: rgba(0, 255, 136, 0.2);
            border-left: 3px solid #00ff88;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .player-name {
            flex: 1;
        }

        .player-score {
            color: #ffd700;
            font-weight: bold;
        }

        /* Speedometer */
        #speedometer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 10px;
            min-width: 150px;
            display: none;
        }

        .speed-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00ff88;
            text-align: center;
        }

        .speed-label {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
        }

        /* Controls Info */
        #controlsInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 10px;
            font-size: 0.9rem;
            display: none;
        }

        /* Mini Map */
        #miniMap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: none;
        }

        #miniMapCanvas {
            width: 100%;
            height: 100%;
        }

        /* Lap Counter */
        #lapCounter {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 10px;
            font-size: 1.2rem;
            display: none;
        }

        /* Loading Screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1003;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.5rem;
            color: white;
        }

        /* Game End Screen */
        #gameEndScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 1002;
        }

        #gameEndScreen.show {
            opacity: 1;
            pointer-events: all;
        }

        .game-end-title {
            font-size: 4rem;
            color: #ffd700;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .game-end-subtitle {
            font-size: 1.5rem;
            color: white;
            margin-bottom: 2rem;
        }

        .restart-button {
            background: linear-gradient(45deg, #00ff88, #0088ff);
            color: white;
            border: none;
            padding: 1rem 3rem;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 2rem;
            transition: all 0.3s ease;
        }

        .restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .selection-title {
                font-size: 2rem;
            }
            
            #vehicleGrid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 1rem;
            }
            
            #gameHUD {
                top: 10px;
                left: 10px;
                padding: 0.5rem;
                min-width: 200px;
                font-size: 0.9rem;
            }
            
            #miniMap {
                width: 150px;
                height: 150px;
                top: 10px;
                right: 10px;
            }
            
            #speedometer {
                bottom: 10px;
                left: 10px;
                padding: 0.5rem;
                min-width: 120px;
            }
            
            .speed-value {
                font-size: 1.5rem;
            }
            
            #controlsInfo {
                bottom: 10px;
                right: 10px;
                font-size: 0.8rem;
                padding: 0.5rem;
            }
            
            #lapCounter {
                left: 10px;
                font-size: 1rem;
                padding: 0.5rem;
            }
        }

        /* Vehicle Colors */
        .color-player { background: #00ff88; }
        .color-bot-1 { background: #ff0080; }
        .color-bot-2 { background: #0088ff; }
        .color-bot-3 { background: #ff8c00; }
        .color-bot-4 { background: #aa00ff; }
        .color-bot-5 { background: #00ffff; }
        .color-bot-6 { background: #ffff00; }
        .color-bot-7 { background: #ff5555; }

        /* Loading Progress */
        .progress-bar {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 1rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #0088ff);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    
    <div id="uiOverlay">
        <!-- Loading Screen -->
        <div id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading Game Assets...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="loadingProgress"></div>
            </div>
        </div>
        
        <!-- Vehicle Selection Screen -->
        <div id="selectionScreen" style="display: none;">
            <h1 class="selection-title">üèÅ Select Your Vehicle üèÅ</h1>
            <div id="vehicleGrid"></div>
            <button id="startButton" disabled>START RACE</button>
        </div>
        
        <!-- Game HUD -->
        <div id="gameHUD">
            <div class="hud-section">
                <div class="hud-title">PLAYERS</div>
                <div id="playersList"></div>
            </div>
            <div class="hud-section">
                <div class="hud-title">POSITION</div>
                <div id="positionDisplay">1st</div>
            </div>
        </div>
        
        <!-- Lap Counter -->
        <div id="lapCounter">
            <div>LAP: <span id="currentLap">1</span>/<span id="totalLaps">3</span></div>
        </div>
        
        <!-- Speedometer -->
        <div id="speedometer">
            <div class="speed-value">0</div>
            <div class="speed-label">KM/H</div>
        </div>
        
        <!-- Controls Info -->
        <div id="controlsInfo">
            <div><strong>WASD</strong> - Drive</div>
            <div><strong>Space</strong> - Brake</div>
            <div><strong>Shift</strong> - Boost</div>
            <div><strong>R</strong> - Reset Position</div>
            <div><strong>ESC</strong> - Menu</div>
        </div>
        
        <!-- Mini Map -->
        <div id="miniMap">
            <canvas id="miniMapCanvas"></canvas>
        </div>
        
        <!-- Game End Screen -->
        <div id="gameEndScreen">
            <h1 class="game-end-title">RACE COMPLETE!</h1>
            <div class="game-end-subtitle" id="finalMessage"></div>
            <div id="finalScores"></div>
            <button class="restart-button" onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        class VehicleGame {
            constructor() {
                // Core Three.js objects
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                
                // Game state
                this.gameStarted = false;
                this.selectedVehicle = null;
                this.vehicles = [];
                this.bots = [];
                this.playerVehicle = null;
                this.road = null;
                this.checkpoints = [];
                this.currentCheckpoint = 0;
                
                // Physics
                this.clock = new THREE.Clock();
                this.keys = {};
                
                // Vehicle properties
                this.vehicleColors = [
                    0x00ff88, 0xff0080, 0x0088ff, 0xff8c00,
                    0xaa00ff, 0x00ffff, 0xffff00, 0xff5555
                ];
                
                // Game settings
                this.lapCount = 3;
                this.playerLap = 1;
                this.playerPosition = 1;
                this.gameTime = 0;
                
                // Texture loader
                this.textureLoader = new THREE.TextureLoader();
                this.vehicleTextures = new Map();
                
                // DOM elements
                this.loadingScreen = document.getElementById('loadingScreen');
                this.selectionScreen = document.getElementById('selectionScreen');
                this.startButton = document.getElementById('startButton');
                this.vehicleGrid = document.getElementById('vehicleGrid');
                this.gameHUD = document.getElementById('gameHUD');
                this.speedometer = document.getElementById('speedometer');
                this.controlsInfo = document.getElementById('controlsInfo');
                this.miniMap = document.getElementById('miniMap');
                this.miniMapCanvas = document.getElementById('miniMapCanvas');
                this.miniMapCtx = this.miniMapCanvas.getContext('2d');
                this.lapCounter = document.getElementById('lapCounter');
                this.currentLapSpan = document.getElementById('currentLap');
                this.totalLapsSpan = document.getElementById('totalLaps');
                this.positionDisplay = document.getElementById('positionDisplay');
                this.gameEndScreen = document.getElementById('gameEndScreen');
                this.finalMessage = document.getElementById('finalMessage');
                this.finalScores = document.getElementById('finalScores');
                this.playersList = document.getElementById('playersList');
                this.loadingProgress = document.getElementById('loadingProgress');
                
                // Initialize
                this.init();
            }
            
            init() {
                this.setupScene();
                this.setupEventListeners();
                this.loadAssets();
            }
            
            setupScene() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 10, 500);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 10, 20);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                // Add lights
                this.setupLights();
                
                // Create environment
                this.createTrack();
                
                // Setup controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enabled = false;
                this.controls.maxDistance = 50;
                this.controls.minDistance = 5;
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupLights() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Hemisphere light for sky color
                const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.3);
                this.scene.add(hemisphereLight);
            }
            
            createTrack() {
                // Create road surface
                const roadGeometry = new THREE.PlaneGeometry(100, 400);
                const roadMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.8,
                    metalness: 0.2
                });
                this.road = new THREE.Mesh(roadGeometry, roadMaterial);
                this.road.rotation.x = -Math.PI / 2;
                this.road.receiveShadow = true;
                this.scene.add(this.road);
                
                // Add road markings
                for (let i = -190; i <= 190; i += 20) {
                    const lineGeometry = new THREE.PlaneGeometry(2, 10);
                    const lineMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(0, 0.01, i);
                    this.scene.add(line);
                }
                
                // Add grass
                const grassGeometry = new THREE.PlaneGeometry(200, 400);
                const grassMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2d5a27,
                    roughness: 0.9
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.y = -0.1;
                this.scene.add(grass);
                
                // Add barriers
                const barrierGeometry = new THREE.BoxGeometry(200, 2, 1);
                const barrierMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                
                const barrier1 = new THREE.Mesh(barrierGeometry, barrierMaterial);
                barrier1.position.set(0, 1, -200);
                this.scene.add(barrier1);
                
                const barrier2 = new THREE.Mesh(barrierGeometry, barrierMaterial);
                barrier2.position.set(0, 1, 200);
                this.scene.add(barrier2);
                
                // Add checkpoints
                this.createCheckpoints();
            }
            
            createCheckpoints() {
                const checkpointGeometry = new THREE.BoxGeometry(20, 5, 1);
                const checkpointMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.5,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                
                for (let i = -180; i <= 180; i += 40) {
                    const checkpoint = new THREE.Mesh(checkpointGeometry, checkpointMaterial);
                    checkpoint.position.set(0, 2.5, i);
                    checkpoint.rotation.y = Math.PI / 2;
                    this.scene.add(checkpoint);
                    this.checkpoints.push({
                        mesh: checkpoint,
                        position: new THREE.Vector3(0, 0, i),
                        passed: false
                    });
                }
            }
            
            setupEventListeners() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    if (e.key === 'Escape') {
                        this.togglePause();
                    }
                    
                    if (e.key === 'r' || e.key === 'R') {
                        if (this.playerVehicle) {
                            this.resetPlayerPosition();
                        }
                    }
                    
                    // Boost
                    if (e.key === 'shift') {
                        if (this.playerVehicle) {
                            this.playerVehicle.isBoosting = true;
                        }
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    
                    if (e.key === 'Shift') {
                        if (this.playerVehicle) {
                            this.playerVehicle.isBoosting = false;
                        }
                    }
                });
                
                // Start button
                this.startButton.addEventListener('click', () => this.startGame());
            }
            
            async loadAssets() {
                try {
                    // First load the texture
                    this.updateLoadingProgress(10, 'Loading texture...');
                    
                    // Load color.png texture
                    const texture = await new Promise((resolve, reject) => {
                        this.textureLoader.load(
                            'color.png',
                            (texture) => {
                                texture.flipY = false;
                                texture.encoding = THREE.sRGBEncoding;
                                resolve(texture);
                            },
                            undefined,
                            (error) => {
                                console.warn('Could not load color.png, using default colors:', error);
                                resolve(null);
                            }
                        );
                    });
                    
                    this.updateLoadingProgress(30, 'Loading 3D models...');
                    
                    // Setup GLTF loader with texture
                    const loader = new GLTFLoader();
                    
                    // Setup DRACO loader for compressed models
                    const dracoLoader = new DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                    loader.setDRACOLoader(dracoLoader);
                    
                    // Try to load .gltf first, then .glb
                    let gltf;
                    try {
                        gltf = await loader.loadAsync('cars.gltf');
                    } catch (gltfError) {
                        console.log('.gltf not found, trying .glb...');
                        gltf = await loader.loadAsync('cars.glb');
                    }
                    
                    this.updateLoadingProgress(70, 'Processing vehicles...');
                    
                    // Extract vehicles from the GLTF scene
                    this.extractVehiclesFromGLTF(gltf.scene, texture);
                    
                    // If no vehicles found, create placeholders
                    if (this.vehicles.length === 0) {
                        console.warn('No vehicles found in GLTF file, creating placeholders');
                        this.createPlaceholderVehicles();
                    }
                    
                    console.log(`Loaded ${this.vehicles.length} vehicles`);
                    
                    this.updateLoadingProgress(90, 'Creating UI...');
                    
                    // Create vehicle selection UI
                    this.createVehicleSelectionUI();
                    
                    this.updateLoadingProgress(100, 'Ready!');
                    
                    // Hide loading screen after a brief delay
                    setTimeout(() => {
                        this.loadingScreen.style.display = 'none';
                        this.selectionScreen.style.display = 'flex';
                    }, 500);
                    
                } catch (error) {
                    console.error('Error loading assets:', error);
                    this.createPlaceholderVehicles();
                    this.createVehicleSelectionUI();
                    this.loadingScreen.style.display = 'none';
                    this.selectionScreen.style.display = 'flex';
                }
            }
            
            updateLoadingProgress(percent, message) {
                this.loadingProgress.style.width = `${percent}%`;
                document.querySelector('.loading-text').textContent = message;
            }
            
            extractVehiclesFromGLTF(scene, texture) {
                // Find all meshes that could be vehicles
                const vehicleMeshes = [];
                
                scene.traverse((child) => {
                    if (child.isMesh) {
                        // Check if this mesh could be a vehicle part
                        const isVehiclePart = 
                            child.name.toLowerCase().includes('car') ||
                            child.name.toLowerCase().includes('vehicle') ||
                            child.name.toLowerCase().includes('truck') ||
                            child.name.toLowerCase().includes('bus') ||
                            child.name.toLowerCase().includes('body') ||
                            child.name.toLowerCase().includes('chassis') ||
                            child.geometry.boundingSphere?.radius > 0.5;
                        
                        if (isVehiclePart) {
                            vehicleMeshes.push(child);
                        }
                    }
                });
                
                // Group meshes by proximity to find complete vehicles
                const vehicleGroups = this.groupVehicleMeshes(vehicleMeshes);
                
                // Create vehicle objects from groups
                vehicleGroups.forEach((group, index) => {
                    const vehicle = this.createVehicleFromMeshes(group, index, texture);
                    this.vehicles.push(vehicle);
                });
            }
            
            groupVehicleMeshes(meshes) {
                const groups = [];
                const visited = new Set();
                
                for (let i = 0; i < meshes.length; i++) {
                    if (visited.has(i)) continue;
                    
                    const group = [meshes[i]];
                    visited.add(i);
                    
                    // Find nearby meshes
                    for (let j = i + 1; j < meshes.length; j++) {
                        if (visited.has(j)) continue;
                        
                        const distance = meshes[i].position.distanceTo(meshes[j].position);
                        if (distance < 5) { // Meshes within 5 units are likely part of same vehicle
                            group.push(meshes[j]);
                            visited.add(j);
                        }
                    }
                    
                    groups.push(group);
                }
                
                return groups;
            }
            
            createVehicleFromMeshes(meshes, index, texture) {
                // Create a group to hold all vehicle parts
                const vehicleGroup = new THREE.Group();
                
                // Clone and add all meshes to the group
                meshes.forEach(mesh => {
                    const clonedMesh = mesh.clone();
                    
                    // Apply texture if available
                    if (texture && clonedMesh.material) {
                        if (Array.isArray(clonedMesh.material)) {
                            clonedMesh.material = clonedMesh.material.map(mat => {
                                const newMat = mat.clone();
                                newMat.map = texture;
                                newMat.needsUpdate = true;
                                return newMat;
                            });
                        } else {
                            clonedMesh.material = clonedMesh.material.clone();
                            clonedMesh.material.map = texture;
                            clonedMesh.material.needsUpdate = true;
                        }
                    }
                    
                    clonedMesh.castShadow = true;
                    clonedMesh.receiveShadow = true;
                    vehicleGroup.add(clonedMesh);
                });
                
                // Calculate bounding box for the entire vehicle
                const bbox = new THREE.Box3().setFromObject(vehicleGroup);
                const size = bbox.getSize(new THREE.Vector3());
                const center = bbox.getCenter(new THREE.Vector3());
                
                // Center the vehicle
                vehicleGroup.position.sub(center);
                
                // Determine vehicle type based on size
                let type = 'Car';
                if (size.x > 4 || size.z > 8) type = 'Truck';
                if (size.y > 3) type = 'SUV';
                if (size.x < 2 && size.z < 4) type = 'Sports Car';
                
                // Calculate stats based on size
                const speed = 8 + (12 - size.length()) / 2; // Smaller = faster
                const handling = 0.5 + (3 - Math.max(size.x, size.z)) / 6;
                
                return {
                    name: `Vehicle ${index + 1}`,
                    type: type,
                    mesh: vehicleGroup,
                    originalMeshes: meshes,
                    speed: THREE.MathUtils.clamp(speed, 5, 15),
                    handling: THREE.MathUtils.clamp(handling, 0.3, 0.9),
                    color: this.vehicleColors[index % this.vehicleColors.length],
                    size: size,
                    bbox: bbox
                };
            }
            
            createPlaceholderVehicles() {
                const vehicleTypes = [
                    { name: 'Sports Car', scale: [1.5, 1, 4], speed: 12, handling: 0.9 },
                    { name: 'SUV', scale: [2, 1.5, 5], speed: 8, handling: 0.7 },
                    { name: 'Truck', scale: [2.5, 1.8, 7], speed: 6, handling: 0.5 },
                    { name: 'Race Car', scale: [1.2, 0.8, 3.5], speed: 14, handling: 0.95 }
                ];
                
                for (let i = 0; i < 4; i++) {
                    const type = vehicleTypes[i];
                    const geometry = new THREE.BoxGeometry(...type.scale);
                    const material = new THREE.MeshStandardMaterial({
                        color: this.vehicleColors[i],
                        roughness: 0.5,
                        metalness: 0.5
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // Create a group for the vehicle
                    const vehicleGroup = new THREE.Group();
                    vehicleGroup.add(mesh);
                    
                    // Add wheels
                    this.addWheels(vehicleGroup, type.scale);
                    
                    this.vehicles.push({
                        name: type.name,
                        type: type.name,
                        mesh: vehicleGroup,
                        originalMeshes: [mesh],
                        speed: type.speed,
                        handling: type.handling,
                        color: this.vehicleColors[i],
                        size: new THREE.Vector3(...type.scale),
                        bbox: new THREE.Box3().setFromObject(vehicleGroup)
                    });
                }
            }
            
            addWheels(vehicleGroup, scale) {
                const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 8);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
                
                const [width, height, length] = scale;
                const wheelPositions = [
                    { x: -width/2 + 0.4, y: -height/2, z: length/2 - 0.5, rotation: Math.PI / 2 },
                    { x: width/2 - 0.4, y: -height/2, z: length/2 - 0.5, rotation: Math.PI / 2 },
                    { x: -width/2 + 0.4, y: -height/2, z: -length/2 + 0.5, rotation: Math.PI / 2 },
                    { x: width/2 - 0.4, y: -height/2, z: -length/2 + 0.5, rotation: Math.PI / 2 }
                ];
                
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.position.set(pos.x, pos.y, pos.z);
                    wheel.rotation.z = pos.rotation;
                    vehicleGroup.add(wheel);
                });
            }
            
            createVehicleSelectionUI() {
                this.vehicleGrid.innerHTML = '';
                
                this.vehicles.forEach((vehicle, index) => {
                    const card = document.createElement('div');
                    card.className = 'vehicle-card';
                    card.dataset.index = index;
                    
                    // Create preview container
                    const preview = document.createElement('div');
                    preview.className = 'vehicle-preview';
                    preview.id = `preview-${index}`;
                    
                    // Create vehicle info
                    const name = document.createElement('div');
                    name.className = 'vehicle-name';
                    name.textContent = vehicle.name;
                    
                    const type = document.createElement('div');
                    type.className = 'vehicle-type';
                    type.textContent = vehicle.type;
                    
                    const stats = document.createElement('div');
                    stats.className = 'vehicle-stats';
                    stats.innerHTML = `
                        <div>Speed: ${vehicle.speed.toFixed(1)}</div>
                        <div>Handling: ${vehicle.handling.toFixed(1)}</div>
                        <div>Size: ${vehicle.size.x.toFixed(1)} x ${vehicle.size.z.toFixed(1)}</div>
                    `;
                    
                    card.appendChild(preview);
                    card.appendChild(name);
                    card.appendChild(type);
                    card.appendChild(stats);
                    
                    card.addEventListener('click', () => this.selectVehicle(index));
                    
                    this.vehicleGrid.appendChild(card);
                    
                    // Create 3D preview for this vehicle
                    this.createVehiclePreview(index);
                });
                
                // Enable start button when a vehicle is selected
                this.startButton.disabled = true;
                this.totalLapsSpan.textContent = this.lapCount;
            }
            
            createVehiclePreview(index) {
                const previewScene = new THREE.Scene();
                const previewCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
                const previewRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                
                previewRenderer.setSize(300, 200);
                previewRenderer.setClearColor(0x000000, 0);
                
                const container = document.getElementById(`preview-${index}`);
                if (!container) return;
                
                container.appendChild(previewRenderer.domElement);
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                previewScene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                previewScene.add(directionalLight);
                
                // Add vehicle
                const vehicle = this.vehicles[index];
                const mesh = vehicle.mesh.clone();
                
                // Center and scale the vehicle for preview
                const box = new THREE.Box3().setFromObject(mesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                mesh.position.sub(center);
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 3 / maxDim;
                mesh.scale.multiplyScalar(scale);
                
                previewScene.add(mesh);
                
                // Position camera
                previewCamera.position.set(5, 3, 5);
                previewCamera.lookAt(0, 0, 0);
                
                // Auto-rotate animation
                let angle = 0;
                const animatePreview = () => {
                    if (!container.isConnected) {
                        previewRenderer.dispose();
                        return;
                    }
                    
                    angle += 0.01;
                    mesh.rotation.y = angle;
                    
                    previewRenderer.render(previewScene, previewCamera);
                    requestAnimationFrame(animatePreview);
                };
                
                animatePreview();
            }
            
            selectVehicle(index) {
                // Remove selection from all cards
                document.querySelectorAll('.vehicle-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                // Select clicked card
                const card = document.querySelector(`.vehicle-card[data-index="${index}"]`);
                if (card) {
                    card.classList.add('selected');
                }
                
                this.selectedVehicle = index;
                this.startButton.disabled = false;
            }
            
            startGame() {
                if (this.selectedVehicle === null) return;
                
                // Hide selection screen
                this.selectionScreen.style.opacity = '0';
                setTimeout(() => {
                    this.selectionScreen.style.display = 'none';
                }, 500);
                
                // Show game UI
                this.gameHUD.style.display = 'block';
                this.speedometer.style.display = 'block';
                this.controlsInfo.style.display = 'block';
                this.miniMap.style.display = 'block';
                this.lapCounter.style.display = 'block';
                
                // Initialize game
                this.initializeGame();
                this.gameStarted = true;
                
                // Start game loop
                this.animate();
            }
            
            initializeGame() {
                // Clear existing vehicles
                this.bots.forEach(bot => this.scene.remove(bot.mesh));
                this.bots = [];
                
                // Create player vehicle
                const playerData = this.vehicles[this.selectedVehicle];
                this.playerVehicle = this.createGameVehicle(playerData, true);
                this.playerVehicle.mesh.position.set(-20, 1, -180);
                this.playerVehicle.name = "Player";
                this.scene.add(this.playerVehicle.mesh);
                
                // Create bot vehicles from remaining vehicles
                let botIndex = 0;
                for (let i = 0; i < this.vehicles.length; i++) {
                    if (i !== this.selectedVehicle) {
                        const botData = this.vehicles[i];
                        const bot = this.createGameVehicle(botData, false);
                        bot.name = `Bot ${botIndex + 1}`;
                        bot.index = botIndex;
                        bot.mesh.position.set(20 + (botIndex * 10), 1, -180 + (botIndex * 5));
                        bot.lap = 1;
                        bot.checkpoint = 0;
                        bot.score = 0;
                        bot.aiState = 'racing';
                        bot.aiTargetX = 0;
                        bot.aiTargetSpeed = bot.maxSpeed * 0.7;
                        
                        this.scene.add(bot.mesh);
                        this.bots.push(bot);
                        botIndex++;
                        
                        // Limit to 7 bots for performance
                        if (botIndex >= 7) break;
                    }
                }
                
                // Setup camera to follow player
                this.setupFollowCamera();
                
                // Update HUD
                this.updateHUD();
                this.updateMiniMap();
                
                // Reset game state
                this.playerLap = 1;
                this.currentCheckpoint = 0;
                this.gameTime = 0;
                this.playerPosition = 1;
                this.currentLapSpan.textContent = '1';
            }
            
            createGameVehicle(vehicleData, isPlayer) {
                const mesh = vehicleData.mesh.clone();
                
                // Apply player color if needed
                if (isPlayer) {
                    mesh.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    mat.color.setHex(0x00ff88);
                                    mat.emissive.setHex(0x003322);
                                    mat.emissiveIntensity = 0.2;
                                });
                            } else {
                                child.material.color.setHex(0x00ff88);
                                child.material.emissive.setHex(0x003322);
                                child.material.emissiveIntensity = 0.2;
                            }
                        }
                    });
                }
                
                return {
                    mesh: mesh,
                    speed: vehicleData.speed,
                    handling: vehicleData.handling,
                    velocity: new THREE.Vector3(),
                    rotation: 0,
                    currentSpeed: 0,
                    maxSpeed: vehicleData.speed * 2,
                    acceleration: 0.2,
                    braking: 0.3,
                    turningSpeed: vehicleData.handling * 0.08,
                    isPlayer: isPlayer,
                    lap: 1,
                    checkpoint: 0,
                    score: 0,
                    isBoosting: false,
                    boostAmount: 100,
                    size: vehicleData.size
                };
            }
            
            setupFollowCamera() {
                // Create a camera target that follows the player
                this.cameraTarget = new THREE.Object3D();
                this.scene.add(this.cameraTarget);
                
                // Enable controls for debugging view
                this.controls.enabled = true;
                this.controls.target = this.playerVehicle.mesh.position;
            }
            
            updateHUD() {
                // Update players list
                this.playersList.innerHTML = '';
                
                // Calculate all vehicle positions
                const allVehicles = [
                    { ...this.playerVehicle, name: 'Player', colorClass: 'color-player' },
                    ...this.bots.map((bot, idx) => ({
                        ...bot,
                        name: bot.name,
                        colorClass: `color-bot-${idx + 1}`
                    }))
                ];
                
                // Sort by progress (lap * 1000 + checkpoint * 100 + position.z)
                allVehicles.sort((a, b) => {
                    const aProgress = (a.lap * 1000) + (a.checkpoint * 100) + a.mesh.position.z;
                    const bProgress = (b.lap * 1000) + (b.checkpoint * 100) + b.mesh.position.z;
                    return bProgress - aProgress; // Higher progress = better position
                });
                
                // Update player position
                this.playerPosition = allVehicles.findIndex(v => v.name === 'Player') + 1;
                this.positionDisplay.textContent = this.getOrdinal(this.playerPosition);
                
                // Display all vehicles in order
                allVehicles.forEach((vehicle, index) => {
                    const vehicleElement = document.createElement('div');
                    vehicleElement.className = `player-info ${vehicle.name === 'Player' ? 'active' : ''}`;
                    vehicleElement.innerHTML = `
                        <div class="player-color ${vehicle.colorClass}"></div>
                        <div class="player-name">${vehicle.name}</div>
                        <div class="player-score">Lap: ${vehicle.lap}/${this.lapCount}</div>
                    `;
                    this.playersList.appendChild(vehicleElement);
                });
                
                // Update speedometer
                if (this.playerVehicle) {
                    const speed = Math.abs(this.playerVehicle.currentSpeed * 50).toFixed(0);
                    document.querySelector('.speed-value').textContent = speed;
                }
                
                // Update lap counter
                this.currentLapSpan.textContent = this.playerLap;
            }
            
            updateMiniMap() {
                const ctx = this.miniMapCtx;
                const width = this.miniMapCanvas.width = this.miniMap.clientWidth;
                const height = this.miniMapCanvas.height = this.miniMap.clientHeight;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw track background
                ctx.fillStyle = 'rgba(30, 30, 30, 0.9)';
                ctx.fillRect(0, 0, width, height);
                
                // Draw track (simplified rectangle)
                ctx.fillStyle = 'rgba(51, 51, 51, 0.9)';
                ctx.fillRect(width * 0.25, 10, width * 0.5, height - 20);
                
                // Draw center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(width / 2, 10);
                ctx.lineTo(width / 2, height - 10);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw checkpoints
                this.checkpoints.forEach((checkpoint, index) => {
                    const progress = (checkpoint.position.z + 200) / 400;
                    const yPos = 10 + (height - 20) * (1 - progress);
                    ctx.fillStyle = checkpoint.passed ? '#00ff00' : '#ffff00';
                    ctx.beginPath();
                    ctx.rect(width * 0.25 - 5, yPos - 2, width * 0.5 + 10, 4);
                    ctx.fill();
                });
                
                // Draw player
                if (this.playerVehicle) {
                    const playerZ = this.playerVehicle.mesh.position.z;
                    const progress = (playerZ + 200) / 400;
                    const yPos = 10 + (height - 20) * (1 - progress);
                    const xPos = width / 2 + (this.playerVehicle.mesh.position.x / 50) * (width * 0.25);
                    
                    // Draw direction indicator
                    ctx.save();
                    ctx.translate(xPos, yPos);
                    ctx.rotate(-this.playerVehicle.mesh.rotation.y);
                    
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(0, -6);
                    ctx.lineTo(4, 6);
                    ctx.lineTo(-4, 6);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // Draw player dot
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.arc(xPos, yPos, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw bots
                this.bots.forEach((bot, index) => {
                    const botZ = bot.mesh.position.z;
                    const progress = (botZ + 200) / 400;
                    const yPos = 10 + (height - 20) * (1 - progress);
                    const xPos = width / 2 + (bot.mesh.position.x / 50) * (width * 0.25);
                    
                    const colors = ['#ff0080', '#0088ff', '#ff8c00', '#aa00ff', '#00ffff', '#ffff00', '#ff5555'];
                    
                    ctx.fillStyle = colors[index % colors.length];
                    ctx.beginPath();
                    ctx.arc(xPos, yPos, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            updateBotAI(bot, deltaTime) {
                // Simple AI with multiple states
                switch (bot.aiState) {
                    case 'racing':
                        this.updateRacingAI(bot, deltaTime);
                        break;
                    case 'overtaking':
                        this.updateOvertakingAI(bot, deltaTime);
                        break;
                    case 'recovering':
                        this.updateRecoveringAI(bot, deltaTime);
                        break;
                }
                
                // State transitions
                if (Math.abs(bot.mesh.position.x) > 40 && bot.aiState !== 'recovering') {
                    bot.aiState = 'recovering';
                    bot.aiRecoverTime = 0;
                }
                
                if (bot.aiState === 'recovering' && Math.abs(bot.mesh.position.x) < 10) {
                    bot.aiState = 'racing';
                }
                
                // Check checkpoints
                this.checkBotCheckpoints(bot);
                
                // Update lap if reached end
                if (bot.mesh.position.z > 190 && bot.lap < this.lapCount) {
                    bot.lap++;
                    bot.mesh.position.z = -180;
                    bot.checkpoint = 0;
                }
            }
            
            updateRacingAI(bot, deltaTime) {
                // Target speed with some variation
                bot.aiTargetSpeed = bot.maxSpeed * (0.6 + Math.random() * 0.3);
                
                // Move toward center of track with some randomness
                bot.aiTargetX = (Math.random() - 0.5) * 20;
                
                // Adjust speed toward target
                if (bot.currentSpeed < bot.aiTargetSpeed) {
                    bot.currentSpeed = Math.min(
                        bot.currentSpeed + bot.acceleration * deltaTime,
                        bot.aiTargetSpeed
                    );
                } else {
                    bot.currentSpeed = Math.max(
                        bot.currentSpeed - 0.1 * deltaTime,
                        bot.aiTargetSpeed * 0.8
                    );
                }
                
                // Adjust position toward target
                const xDiff = bot.aiTargetX - bot.mesh.position.x;
                bot.rotation += Math.sign(xDiff) * bot.turningSpeed * deltaTime * 0.5;
                
                // Apply movement
                bot.velocity.z = -bot.currentSpeed;
                bot.velocity.x = Math.sin(bot.rotation) * 2;
                
                // Update position
                bot.mesh.position.x += bot.velocity.x * deltaTime;
                bot.mesh.position.z += bot.velocity.z * deltaTime;
                
                // Smooth rotation
                bot.rotation *= 0.95;
                bot.mesh.rotation.y = bot.rotation;
            }
            
            updateOvertakingAI(bot, deltaTime) {
                // Similar to racing but with more aggressive steering
                this.updateRacingAI(bot, deltaTime);
                bot.aiTargetSpeed = bot.maxSpeed * 0.9;
            }
            
            updateRecoveringAI(bot, deltaTime) {
                bot.aiRecoverTime += deltaTime;
                
                // Try to get back to track center
                const targetX = 0;
                const xDiff = targetX - bot.mesh.position.x;
                bot.rotation = Math.atan2(xDiff, 10) * 0.5;
                
                // Slow down while recovering
                bot.currentSpeed = Math.max(bot.currentSpeed - 0.2 * deltaTime, bot.maxSpeed * 0.3);
                
                // Apply movement
                bot.velocity.z = -bot.currentSpeed;
                bot.velocity.x = Math.sin(bot.rotation) * 3;
                
                // Update position
                bot.mesh.position.x += bot.velocity.x * deltaTime;
                bot.mesh.position.z += bot.velocity.z * deltaTime;
                
                bot.mesh.rotation.y = bot.rotation;
                
                // Return to racing after 2 seconds
                if (bot.aiRecoverTime > 2) {
                    bot.aiState = 'racing';
                }
            }
            
            checkBotCheckpoints(bot) {
                this.checkpoints.forEach((checkpoint, index) => {
                    const distance = bot.mesh.position.distanceTo(checkpoint.position);
                    if (distance < 15 && index > bot.checkpoint) {
                        bot.checkpoint = index;
                        bot.score += 100;
                    }
                });
            }
            
            checkPlayerCheckpoints() {
                this.checkpoints.forEach((checkpoint, index) => {
                    const distance = this.playerVehicle.mesh.position.distanceTo(checkpoint.position);
                    if (distance < 15 && index > this.currentCheckpoint) {
                        this.currentCheckpoint = index;
                        checkpoint.passed = true;
                        checkpoint.mesh.material.color.setHex(0x00ff00);
                        
                        // Add score
                        this.playerVehicle.score += 100;
                        
                        // Visual feedback
                        checkpoint.mesh.material.emissiveIntensity = 1.0;
                        setTimeout(() => {
                            checkpoint.mesh.material.emissiveIntensity = 0.5;
                        }, 200);
                    }
                });
                
                // Check if lap is complete
                if (this.playerVehicle.mesh.position.z > 190 && this.currentCheckpoint === this.checkpoints.length - 1) {
                    this.playerLap++;
                    this.currentCheckpoint = 0;
                    
                    // Reset checkpoints
                    this.checkpoints.forEach(checkpoint => {
                        checkpoint.passed = false;
                        checkpoint.mesh.material.color.setHex(0xffff00);
                    });
                    
                    // Reset position for new lap
                    this.playerVehicle.mesh.position.z = -180;
                    
                    // Update HUD
                    this.currentLapSpan.textContent = this.playerLap;
                    
                    // Check if race is complete
                    if (this.playerLap > this.lapCount) {
                        this.endGame(true);
                    }
                }
            }
            
            updatePlayerControls(deltaTime) {
                if (!this.playerVehicle) return;
                
                const vehicle = this.playerVehicle;
                
                // Boost handling
                const boostMultiplier = vehicle.isBoosting && vehicle.boostAmount > 0 ? 1.5 : 1;
                if (vehicle.isBoosting && vehicle.boostAmount > 0) {
                    vehicle.boostAmount = Math.max(vehicle.boostAmount - 20 * deltaTime, 0);
                } else if (!vehicle.isBoosting && vehicle.boostAmount < 100) {
                    vehicle.boostAmount = Math.min(vehicle.boostAmount + 10 * deltaTime, 100);
                }
                
                // Acceleration
                if (this.keys['w'] || this.keys['arrowup']) {
                    vehicle.currentSpeed = Math.min(
                        vehicle.currentSpeed + vehicle.acceleration * deltaTime * boostMultiplier,
                        vehicle.maxSpeed * boostMultiplier
                    );
                }
                // Braking/Reverse
                else if (this.keys['s'] || this.keys['arrowdown']) {
                    vehicle.currentSpeed = Math.max(
                        vehicle.currentSpeed - vehicle.braking * deltaTime,
                        -vehicle.maxSpeed * 0.5
                    );
                }
                // Space for handbrake
                else if (this.keys[' ']) {
                    vehicle.currentSpeed *= 0.95;
                    vehicle.rotation *= 1.1; // More slide when handbraking
                }
                // Natural deceleration
                else {
                    if (vehicle.currentSpeed > 0) {
                        vehicle.currentSpeed = Math.max(vehicle.currentSpeed - 0.05 * deltaTime, 0);
                    } else if (vehicle.currentSpeed < 0) {
                        vehicle.currentSpeed = Math.min(vehicle.currentSpeed + 0.05 * deltaTime, 0);
                    }
                }
                
                // Turning
                const turnMultiplier = 1 + (vehicle.currentSpeed / vehicle.maxSpeed) * 0.5;
                if (this.keys['a'] || this.keys['arrowleft']) {
                    vehicle.rotation += vehicle.turningSpeed * deltaTime * turnMultiplier;
                }
                if (this.keys['d'] || this.keys['arrowright']) {
                    vehicle.rotation -= vehicle.turningSpeed * deltaTime * turnMultiplier;
                }
                
                // Apply rotation smoothing
                vehicle.rotation *= 0.9;
                
                // Update velocity based on rotation
                vehicle.velocity.x = Math.sin(vehicle.rotation) * vehicle.currentSpeed * 0.5;
                vehicle.velocity.z = -Math.cos(vehicle.rotation) * vehicle.currentSpeed;
                
                // Update position
                vehicle.mesh.position.x += vehicle.velocity.x * deltaTime;
                vehicle.mesh.position.z += vehicle.velocity.z * deltaTime;
                
                // Keep on track (with some allowance)
                if (Math.abs(vehicle.mesh.position.x) > 45) {
                    vehicle.mesh.position.x = THREE.MathUtils.clamp(vehicle.mesh.position.x, -45, 45);
                    vehicle.currentSpeed *= 0.8; // Slow down when hitting barrier
                }
                
                // Update rotation
                vehicle.mesh.rotation.y = vehicle.rotation;
                
                // Update camera
                this.updateCamera(deltaTime);
                
                // Check checkpoints
                this.checkPlayerCheckpoints();
            }
            
            updateCamera(deltaTime) {
                if (!this.playerVehicle || !this.cameraTarget) return;
                
                const vehicle = this.playerVehicle;
                
                // Update camera target
                this.cameraTarget.position.lerp(vehicle.mesh.position, 0.1);
                this.controls.target.lerp(vehicle.mesh.position, 0.1);
                
                // Position camera behind vehicle
                const cameraDistance = 15 + (vehicle.currentSpeed / vehicle.maxSpeed) * 5;
                const cameraHeight = 5 + (vehicle.currentSpeed / vehicle.maxSpeed) * 3;
                
                const cameraOffset = new THREE.Vector3(
                    Math.sin(vehicle.rotation) * -cameraDistance,
                    cameraHeight,
                    Math.cos(vehicle.rotation) * -cameraDistance
                );
                
                const targetPosition = vehicle.mesh.position.clone().add(cameraOffset);
                this.camera.position.lerp(targetPosition, 0.1);
                this.camera.lookAt(this.cameraTarget.position);
            }
            
            resetPlayerPosition() {
                if (this.playerVehicle) {
                    this.playerVehicle.mesh.position.set(-20, 1, -180);
                    this.playerVehicle.mesh.rotation.y = 0;
                    this.playerVehicle.currentSpeed = 0;
                    this.playerVehicle.rotation = 0;
                    this.playerVehicle.boostAmount = 100;
                }
            }
            
            togglePause() {
                // Simple pause toggle
                this.gameStarted = !this.gameStarted;
                if (this.gameStarted) {
                    this.animate();
                }
            }
            
            endGame(win) {
                this.gameStarted = false;
                
                // Show end game screen
                this.gameEndScreen.classList.add('show');
                
                // Set final message
                const positionText = this.getOrdinal(this.playerPosition);
                if (this.playerPosition === 1) {
                    this.finalMessage.textContent = `üèÜ YOU WON! üèÜ`;
                } else if (this.playerPosition <= 3) {
                    this.finalMessage.textContent = `ü•à ${positionText} Place - Great Job!`;
                } else {
                    this.finalMessage.textContent = `${positionText} Place - Better luck next time!`;
                }
                
                // Calculate and display final scores
                this.calculateFinalScores();
            }
            
            calculateFinalScores() {
                // Create array of all vehicles with scores
                const allVehicles = [
                    { ...this.playerVehicle, name: 'Player', colorClass: 'color-player' },
                    ...this.bots.map((bot, idx) => ({
                        ...bot,
                        name: bot.name,
                        colorClass: `color-bot-${idx + 1}`
                    }))
                ];
                
                // Add lap bonus
                allVehicles.forEach(vehicle => {
                    vehicle.totalScore = vehicle.score + (vehicle.lap * 500);
                });
                
                // Sort by total score (descending)
                allVehicles.sort((a, b) => b.totalScore - a.totalScore);
                
                // Display scores
                this.finalScores.innerHTML = '<h3 style="margin-bottom: 20px; color: #ffd700;">Final Scores</h3>';
                allVehicles.forEach((vehicle, index) => {
                    const scoreElement = document.createElement('div');
                    scoreElement.className = 'player-info';
                    scoreElement.style.margin = '10px 0';
                    scoreElement.style.padding = '15px';
                    scoreElement.style.background = index === 0 ? 'rgba(255, 215, 0, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                    scoreElement.innerHTML = `
                        <div style="display: flex; align-items: center; width: 100%;">
                            <div style="font-size: 1.2rem; font-weight: bold; margin-right: 15px; min-width: 30px;">
                                ${index + 1}
                            </div>
                            <div class="player-color ${vehicle.colorClass}" style="margin-right: 10px;"></div>
                            <div style="flex: 1; font-size: 1.1rem;">${vehicle.name}</div>
                            <div style="color: #ffd700; font-weight: bold;">
                                ${vehicle.totalScore} pts
                            </div>
                        </div>
                    `;
                    this.finalScores.appendChild(scoreElement);
                });
            }
            
            getOrdinal(n) {
                const s = ["th", "st", "nd", "rd"];
                const v = n % 100;
                return n + (s[(v - 20) % 10] || s[v] || s[0]);
            }
            
            animate() {
                if (!this.gameStarted) return;
                
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = Math.min(this.clock.getDelta(), 0.1);
                this.gameTime += deltaTime;
                
                // Update player
                if (this.playerVehicle) {
                    this.updatePlayerControls(deltaTime);
                }
                
                // Update bots
                this.bots.forEach(bot => {
                    this.updateBotAI(bot, deltaTime);
                });
                
                // Update HUD
                this.updateHUD();
                this.updateMiniMap();
                
                // Update controls
                this.controls.update();
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Update mini-map
                this.miniMapCanvas.width = this.miniMap.clientWidth;
                this.miniMapCanvas.height = this.miniMap.clientHeight;
                this.updateMiniMap();
            }
        }
        
        // Initialize game when page loads
        window.game = new VehicleGame();
        
        // Global restart function
        window.restartGame = function() {
            // Hide end screen
            document.getElementById('gameEndScreen').classList.remove('show');
            
            // Show selection screen
            document.getElementById('selectionScreen').style.display = 'flex';
            document.getElementById('selectionScreen').style.opacity = '1';
            
            // Hide game UI
            document.getElementById('gameHUD').style.display = 'none';
            document.getElementById('speedometer').style.display = 'none';
            document.getElementById('controlsInfo').style.display = 'none';
            document.getElementById('miniMap').style.display = 'none';
            document.getElementById('lapCounter').style.display = 'none';
            
            // Reset selection
            document.querySelectorAll('.vehicle-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById('startButton').disabled = true;
            window.game.selectedVehicle = null;
        };
    </script>
</body>
</html>
